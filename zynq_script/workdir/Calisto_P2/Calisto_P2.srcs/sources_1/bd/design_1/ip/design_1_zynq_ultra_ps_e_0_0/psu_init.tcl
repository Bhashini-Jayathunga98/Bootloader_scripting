#****************************************************************************
###
#
# @file psu_init.tcl
#
# This file is automatically generated
#
#****************************************************************************
set psu_pll_init_data {
		# : RPLL INIT
		# Register : RPLL_CFG @ 0XFF5E0034</p>

		# PLL loop filter resistor control
		# PSU_CRL_APB_RPLL_CFG_RES                                                        0xc

		# PLL charge pump control
		# PSU_CRL_APB_RPLL_CFG_CP                                                         0x3

		# PLL loop filter high frequency capacitor control
		# PSU_CRL_APB_RPLL_CFG_LFHF                                                       0x3

		# Lock circuit counter setting
		# PSU_CRL_APB_RPLL_CFG_LOCK_CNT                                                   0x36b

		# Lock circuit configuration settings for lock windowsize
		# PSU_CRL_APB_RPLL_CFG_LOCK_DLY                                                   0x3f

		# Helper data. Values are to be looked up in a table from Data Sheet
		#(OFFSET, MASK, VALUE)      (0XFF5E0034, 0xFE7FEDEFU ,0x7E6D6C6CU)  */
    mask_write 0XFF5E0034 0xFE7FEDEF 0x7E6D6C6C
		# : UPDATE FB_DIV
		# Register : RPLL_CTRL @ 0XFF5E0030</p>

		# Mux select for determining which clock feeds this PLL. 0XX pss_ref_clk i
    # s the source 100 video clk is the source 101 pss_alt_ref_clk is the sour
    # ce 110 aux_refclk[X] is the source 111 gt_crx_ref_clk is the source
		# PSU_CRL_APB_RPLL_CTRL_PRE_SRC                                                   0x0

		# The integer portion of the feedback divider to the PLL
		# PSU_CRL_APB_RPLL_CTRL_FBDIV                                                     0x2a

		# This turns on the divide by 2 that is inside of the PLL. This does not c
    # hange the VCO frequency, just the output frequency
		# PSU_CRL_APB_RPLL_CTRL_DIV2                                                      0x1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFF5E0030, 0x00717F00U ,0x00012A00U)  */
    mask_write 0XFF5E0030 0x00717F00 0x00012A00
		# : BY PASS PLL
		# Register : RPLL_CTRL @ 0XFF5E0030</p>

		# Bypasses the PLL clock. The usable clock will be determined from the POS
    # T_SRC field. (This signal may only be toggled after 4 cycles of the old
    # clock and 4 cycles of the new clock. This is not usually an issue, but d
    # esigners must be aware.)
		# PSU_CRL_APB_RPLL_CTRL_BYPASS                                                    1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFF5E0030, 0x00000008U ,0x00000008U)  */
    mask_write 0XFF5E0030 0x00000008 0x00000008
		# : ASSERT RESET
		# Register : RPLL_CTRL @ 0XFF5E0030</p>

		# Asserts Reset to the PLL. When asserting reset, the PLL must already be
    # in BYPASS.
		# PSU_CRL_APB_RPLL_CTRL_RESET                                                     1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFF5E0030, 0x00000001U ,0x00000001U)  */
    mask_write 0XFF5E0030 0x00000001 0x00000001
		# : DEASSERT RESET
		# Register : RPLL_CTRL @ 0XFF5E0030</p>

		# Asserts Reset to the PLL. When asserting reset, the PLL must already be
    # in BYPASS.
		# PSU_CRL_APB_RPLL_CTRL_RESET                                                     0

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFF5E0030, 0x00000001U ,0x00000000U)  */
    mask_write 0XFF5E0030 0x00000001 0x00000000
		# : CHECK PLL STATUS
		# Register : PLL_STATUS @ 0XFF5E0040</p>

		# RPLL is locked
		# PSU_CRL_APB_PLL_STATUS_RPLL_LOCK                                                1
    mask_poll 0XFF5E0040 0x00000002
		# : REMOVE PLL BY PASS
		# Register : RPLL_CTRL @ 0XFF5E0030</p>

		# Bypasses the PLL clock. The usable clock will be determined from the POS
    # T_SRC field. (This signal may only be toggled after 4 cycles of the old
    # clock and 4 cycles of the new clock. This is not usually an issue, but d
    # esigners must be aware.)
		# PSU_CRL_APB_RPLL_CTRL_BYPASS                                                    0

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFF5E0030, 0x00000008U ,0x00000000U)  */
    mask_write 0XFF5E0030 0x00000008 0x00000000
		# Register : RPLL_TO_FPD_CTRL @ 0XFF5E0048</p>

		# Divisor value for this clock.
		# PSU_CRL_APB_RPLL_TO_FPD_CTRL_DIVISOR0                                           0x2

		# Control for a clock that will be generated in the LPD, but used in the F
    # PD as a clock source for the peripheral clock muxes.
		#(OFFSET, MASK, VALUE)      (0XFF5E0048, 0x00003F00U ,0x00000200U)  */
    mask_write 0XFF5E0048 0x00003F00 0x00000200
		# : RPLL FRAC CFG
		# : SYSMON CLOCK PRESET TO RPLL AGAIN TO AVOID GLITCH WHEN NEXT IOPLL WILL BE PUT IN BYPASS MODE
		# Register : AMS_REF_CTRL @ 0XFF5E0108</p>

		# 6 bit divider
		# PSU_CRL_APB_AMS_REF_CTRL_DIVISOR1                                               1

		# 6 bit divider
		# PSU_CRL_APB_AMS_REF_CTRL_DIVISOR0                                               35

		# 000 = RPLL; 010 = IOPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_AMS_REF_CTRL_SRCSEL                                                 0

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_AMS_REF_CTRL_CLKACT                                                 1

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E0108, 0x013F3F07U ,0x01012300U)  */
    mask_write 0XFF5E0108 0x013F3F07 0x01012300
		# : IOPLL INIT
		# Register : IOPLL_CFG @ 0XFF5E0024</p>

		# PLL loop filter resistor control
		# PSU_CRL_APB_IOPLL_CFG_RES                                                       0x2

		# PLL charge pump control
		# PSU_CRL_APB_IOPLL_CFG_CP                                                        0x3

		# PLL loop filter high frequency capacitor control
		# PSU_CRL_APB_IOPLL_CFG_LFHF                                                      0x3

		# Lock circuit counter setting
		# PSU_CRL_APB_IOPLL_CFG_LOCK_CNT                                                  0x271

		# Lock circuit configuration settings for lock windowsize
		# PSU_CRL_APB_IOPLL_CFG_LOCK_DLY                                                  0x3f

		# Helper data. Values are to be looked up in a table from Data Sheet
		#(OFFSET, MASK, VALUE)      (0XFF5E0024, 0xFE7FEDEFU ,0x7E4E2C62U)  */
    mask_write 0XFF5E0024 0xFE7FEDEF 0x7E4E2C62
		# : UPDATE FB_DIV
		# Register : IOPLL_CTRL @ 0XFF5E0020</p>

		# Mux select for determining which clock feeds this PLL. 0XX pss_ref_clk i
    # s the source 100 video clk is the source 101 pss_alt_ref_clk is the sour
    # ce 110 aux_refclk[X] is the source 111 gt_crx_ref_clk is the source
		# PSU_CRL_APB_IOPLL_CTRL_PRE_SRC                                                  0x0

		# The integer portion of the feedback divider to the PLL
		# PSU_CRL_APB_IOPLL_CTRL_FBDIV                                                    0x3c

		# This turns on the divide by 2 that is inside of the PLL. This does not c
    # hange the VCO frequency, just the output frequency
		# PSU_CRL_APB_IOPLL_CTRL_DIV2                                                     0x1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFF5E0020, 0x00717F00U ,0x00013C00U)  */
    mask_write 0XFF5E0020 0x00717F00 0x00013C00
		# : BY PASS PLL
		# Register : IOPLL_CTRL @ 0XFF5E0020</p>

		# Bypasses the PLL clock. The usable clock will be determined from the POS
    # T_SRC field. (This signal may only be toggled after 4 cycles of the old
    # clock and 4 cycles of the new clock. This is not usually an issue, but d
    # esigners must be aware.)
		# PSU_CRL_APB_IOPLL_CTRL_BYPASS                                                   1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFF5E0020, 0x00000008U ,0x00000008U)  */
    mask_write 0XFF5E0020 0x00000008 0x00000008
		# : ASSERT RESET
		# Register : IOPLL_CTRL @ 0XFF5E0020</p>

		# Asserts Reset to the PLL. When asserting reset, the PLL must already be
    # in BYPASS.
		# PSU_CRL_APB_IOPLL_CTRL_RESET                                                    1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFF5E0020, 0x00000001U ,0x00000001U)  */
    mask_write 0XFF5E0020 0x00000001 0x00000001
		# : DEASSERT RESET
		# Register : IOPLL_CTRL @ 0XFF5E0020</p>

		# Asserts Reset to the PLL. When asserting reset, the PLL must already be
    # in BYPASS.
		# PSU_CRL_APB_IOPLL_CTRL_RESET                                                    0

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFF5E0020, 0x00000001U ,0x00000000U)  */
    mask_write 0XFF5E0020 0x00000001 0x00000000
		# : CHECK PLL STATUS
		# Register : PLL_STATUS @ 0XFF5E0040</p>

		# IOPLL is locked
		# PSU_CRL_APB_PLL_STATUS_IOPLL_LOCK                                               1
    mask_poll 0XFF5E0040 0x00000001
		# : REMOVE PLL BY PASS
		# Register : IOPLL_CTRL @ 0XFF5E0020</p>

		# Bypasses the PLL clock. The usable clock will be determined from the POS
    # T_SRC field. (This signal may only be toggled after 4 cycles of the old
    # clock and 4 cycles of the new clock. This is not usually an issue, but d
    # esigners must be aware.)
		# PSU_CRL_APB_IOPLL_CTRL_BYPASS                                                   0

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFF5E0020, 0x00000008U ,0x00000000U)  */
    mask_write 0XFF5E0020 0x00000008 0x00000000
		# Register : IOPLL_TO_FPD_CTRL @ 0XFF5E0044</p>

		# Divisor value for this clock.
		# PSU_CRL_APB_IOPLL_TO_FPD_CTRL_DIVISOR0                                          0x3

		# Control for a clock that will be generated in the LPD, but used in the F
    # PD as a clock source for the peripheral clock muxes.
		#(OFFSET, MASK, VALUE)      (0XFF5E0044, 0x00003F00U ,0x00000300U)  */
    mask_write 0XFF5E0044 0x00003F00 0x00000300
		# : IOPLL FRAC CFG
		# : APU_PLL INIT
		# Register : APLL_CFG @ 0XFD1A0024</p>

		# PLL loop filter resistor control
		# PSU_CRF_APB_APLL_CFG_RES                                                        0x2

		# PLL charge pump control
		# PSU_CRF_APB_APLL_CFG_CP                                                         0x3

		# PLL loop filter high frequency capacitor control
		# PSU_CRF_APB_APLL_CFG_LFHF                                                       0x3

		# Lock circuit counter setting
		# PSU_CRF_APB_APLL_CFG_LOCK_CNT                                                   0x2bc

		# Lock circuit configuration settings for lock windowsize
		# PSU_CRF_APB_APLL_CFG_LOCK_DLY                                                   0x3f

		# Helper data. Values are to be looked up in a table from Data Sheet
		#(OFFSET, MASK, VALUE)      (0XFD1A0024, 0xFE7FEDEFU ,0x7E578C62U)  */
    mask_write 0XFD1A0024 0xFE7FEDEF 0x7E578C62
		# : UPDATE FB_DIV
		# Register : APLL_CTRL @ 0XFD1A0020</p>

		# Mux select for determining which clock feeds this PLL. 0XX pss_ref_clk i
    # s the source 100 video clk is the source 101 pss_alt_ref_clk is the sour
    # ce 110 aux_refclk[X] is the source 111 gt_crx_ref_clk is the source
		# PSU_CRF_APB_APLL_CTRL_PRE_SRC                                                   0x0

		# The integer portion of the feedback divider to the PLL
		# PSU_CRF_APB_APLL_CTRL_FBDIV                                                     0x35

		# This turns on the divide by 2 that is inside of the PLL. This does not c
    # hange the VCO frequency, just the output frequency
		# PSU_CRF_APB_APLL_CTRL_DIV2                                                      0x1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A0020, 0x00717F00U ,0x00013500U)  */
    mask_write 0XFD1A0020 0x00717F00 0x00013500
		# : BY PASS PLL
		# Register : APLL_CTRL @ 0XFD1A0020</p>

		# Bypasses the PLL clock. The usable clock will be determined from the POS
    # T_SRC field. (This signal may only be toggled after 4 cycles of the old
    # clock and 4 cycles of the new clock. This is not usually an issue, but d
    # esigners must be aware.)
		# PSU_CRF_APB_APLL_CTRL_BYPASS                                                    1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A0020, 0x00000008U ,0x00000008U)  */
    mask_write 0XFD1A0020 0x00000008 0x00000008
		# : ASSERT RESET
		# Register : APLL_CTRL @ 0XFD1A0020</p>

		# Asserts Reset to the PLL. When asserting reset, the PLL must already be
    # in BYPASS.
		# PSU_CRF_APB_APLL_CTRL_RESET                                                     1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A0020, 0x00000001U ,0x00000001U)  */
    mask_write 0XFD1A0020 0x00000001 0x00000001
		# : DEASSERT RESET
		# Register : APLL_CTRL @ 0XFD1A0020</p>

		# Asserts Reset to the PLL. When asserting reset, the PLL must already be
    # in BYPASS.
		# PSU_CRF_APB_APLL_CTRL_RESET                                                     0

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A0020, 0x00000001U ,0x00000000U)  */
    mask_write 0XFD1A0020 0x00000001 0x00000000
		# : CHECK PLL STATUS
		# Register : PLL_STATUS @ 0XFD1A0044</p>

		# APLL is locked
		# PSU_CRF_APB_PLL_STATUS_APLL_LOCK                                                1
    mask_poll 0XFD1A0044 0x00000001
		# : REMOVE PLL BY PASS
		# Register : APLL_CTRL @ 0XFD1A0020</p>

		# Bypasses the PLL clock. The usable clock will be determined from the POS
    # T_SRC field. (This signal may only be toggled after 4 cycles of the old
    # clock and 4 cycles of the new clock. This is not usually an issue, but d
    # esigners must be aware.)
		# PSU_CRF_APB_APLL_CTRL_BYPASS                                                    0

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A0020, 0x00000008U ,0x00000000U)  */
    mask_write 0XFD1A0020 0x00000008 0x00000000
		# Register : APLL_TO_LPD_CTRL @ 0XFD1A0048</p>

		# Divisor value for this clock.
		# PSU_CRF_APB_APLL_TO_LPD_CTRL_DIVISOR0                                           0x3

		# Control for a clock that will be generated in the FPD, but used in the L
    # PD as a clock source for the peripheral clock muxes.
		#(OFFSET, MASK, VALUE)      (0XFD1A0048, 0x00003F00U ,0x00000300U)  */
    mask_write 0XFD1A0048 0x00003F00 0x00000300
		# : APLL FRAC CFG
		# : DDR_PLL INIT
		# Register : DPLL_CFG @ 0XFD1A0030</p>

		# PLL loop filter resistor control
		# PSU_CRF_APB_DPLL_CFG_RES                                                        0xc

		# PLL charge pump control
		# PSU_CRF_APB_DPLL_CFG_CP                                                         0x3

		# PLL loop filter high frequency capacitor control
		# PSU_CRF_APB_DPLL_CFG_LFHF                                                       0x3

		# Lock circuit counter setting
		# PSU_CRF_APB_DPLL_CFG_LOCK_CNT                                                   0x307

		# Lock circuit configuration settings for lock windowsize
		# PSU_CRF_APB_DPLL_CFG_LOCK_DLY                                                   0x3f

		# Helper data. Values are to be looked up in a table from Data Sheet
		#(OFFSET, MASK, VALUE)      (0XFD1A0030, 0xFE7FEDEFU ,0x7E60EC6CU)  */
    mask_write 0XFD1A0030 0xFE7FEDEF 0x7E60EC6C
		# : UPDATE FB_DIV
		# Register : DPLL_CTRL @ 0XFD1A002C</p>

		# Mux select for determining which clock feeds this PLL. 0XX pss_ref_clk i
    # s the source 100 video clk is the source 101 pss_alt_ref_clk is the sour
    # ce 110 aux_refclk[X] is the source 111 gt_crx_ref_clk is the source
		# PSU_CRF_APB_DPLL_CTRL_PRE_SRC                                                   0x0

		# The integer portion of the feedback divider to the PLL
		# PSU_CRF_APB_DPLL_CTRL_FBDIV                                                     0x30

		# This turns on the divide by 2 that is inside of the PLL. This does not c
    # hange the VCO frequency, just the output frequency
		# PSU_CRF_APB_DPLL_CTRL_DIV2                                                      0x1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A002C, 0x00717F00U ,0x00013000U)  */
    mask_write 0XFD1A002C 0x00717F00 0x00013000
		# : BY PASS PLL
		# Register : DPLL_CTRL @ 0XFD1A002C</p>

		# Bypasses the PLL clock. The usable clock will be determined from the POS
    # T_SRC field. (This signal may only be toggled after 4 cycles of the old
    # clock and 4 cycles of the new clock. This is not usually an issue, but d
    # esigners must be aware.)
		# PSU_CRF_APB_DPLL_CTRL_BYPASS                                                    1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A002C, 0x00000008U ,0x00000008U)  */
    mask_write 0XFD1A002C 0x00000008 0x00000008
		# : ASSERT RESET
		# Register : DPLL_CTRL @ 0XFD1A002C</p>

		# Asserts Reset to the PLL. When asserting reset, the PLL must already be
    # in BYPASS.
		# PSU_CRF_APB_DPLL_CTRL_RESET                                                     1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A002C, 0x00000001U ,0x00000001U)  */
    mask_write 0XFD1A002C 0x00000001 0x00000001
		# : DEASSERT RESET
		# Register : DPLL_CTRL @ 0XFD1A002C</p>

		# Asserts Reset to the PLL. When asserting reset, the PLL must already be
    # in BYPASS.
		# PSU_CRF_APB_DPLL_CTRL_RESET                                                     0

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A002C, 0x00000001U ,0x00000000U)  */
    mask_write 0XFD1A002C 0x00000001 0x00000000
		# : CHECK PLL STATUS
		# Register : PLL_STATUS @ 0XFD1A0044</p>

		# DPLL is locked
		# PSU_CRF_APB_PLL_STATUS_DPLL_LOCK                                                1
    mask_poll 0XFD1A0044 0x00000002
		# : REMOVE PLL BY PASS
		# Register : DPLL_CTRL @ 0XFD1A002C</p>

		# Bypasses the PLL clock. The usable clock will be determined from the POS
    # T_SRC field. (This signal may only be toggled after 4 cycles of the old
    # clock and 4 cycles of the new clock. This is not usually an issue, but d
    # esigners must be aware.)
		# PSU_CRF_APB_DPLL_CTRL_BYPASS                                                    0

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A002C, 0x00000008U ,0x00000000U)  */
    mask_write 0XFD1A002C 0x00000008 0x00000000
		# Register : DPLL_TO_LPD_CTRL @ 0XFD1A004C</p>

		# Divisor value for this clock.
		# PSU_CRF_APB_DPLL_TO_LPD_CTRL_DIVISOR0                                           0x3

		# Control for a clock that will be generated in the FPD, but used in the L
    # PD as a clock source for the peripheral clock muxes.
		#(OFFSET, MASK, VALUE)      (0XFD1A004C, 0x00003F00U ,0x00000300U)  */
    mask_write 0XFD1A004C 0x00003F00 0x00000300
		# : DPLL FRAC CFG
		# : VIDEO_PLL INIT
		# Register : VPLL_CFG @ 0XFD1A003C</p>

		# PLL loop filter resistor control
		# PSU_CRF_APB_VPLL_CFG_RES                                                        0xc

		# PLL charge pump control
		# PSU_CRF_APB_VPLL_CFG_CP                                                         0x3

		# PLL loop filter high frequency capacitor control
		# PSU_CRF_APB_VPLL_CFG_LFHF                                                       0x3

		# Lock circuit counter setting
		# PSU_CRF_APB_VPLL_CFG_LOCK_CNT                                                   0x36b

		# Lock circuit configuration settings for lock windowsize
		# PSU_CRF_APB_VPLL_CFG_LOCK_DLY                                                   0x3f

		# Helper data. Values are to be looked up in a table from Data Sheet
		#(OFFSET, MASK, VALUE)      (0XFD1A003C, 0xFE7FEDEFU ,0x7E6D6C6CU)  */
    mask_write 0XFD1A003C 0xFE7FEDEF 0x7E6D6C6C
		# : UPDATE FB_DIV
		# Register : VPLL_CTRL @ 0XFD1A0038</p>

		# Mux select for determining which clock feeds this PLL. 0XX pss_ref_clk i
    # s the source 100 video clk is the source 101 pss_alt_ref_clk is the sour
    # ce 110 aux_refclk[X] is the source 111 gt_crx_ref_clk is the source
		# PSU_CRF_APB_VPLL_CTRL_PRE_SRC                                                   0x0

		# The integer portion of the feedback divider to the PLL
		# PSU_CRF_APB_VPLL_CTRL_FBDIV                                                     0x2a

		# This turns on the divide by 2 that is inside of the PLL. This does not c
    # hange the VCO frequency, just the output frequency
		# PSU_CRF_APB_VPLL_CTRL_DIV2                                                      0x1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A0038, 0x00717F00U ,0x00012A00U)  */
    mask_write 0XFD1A0038 0x00717F00 0x00012A00
		# : BY PASS PLL
		# Register : VPLL_CTRL @ 0XFD1A0038</p>

		# Bypasses the PLL clock. The usable clock will be determined from the POS
    # T_SRC field. (This signal may only be toggled after 4 cycles of the old
    # clock and 4 cycles of the new clock. This is not usually an issue, but d
    # esigners must be aware.)
		# PSU_CRF_APB_VPLL_CTRL_BYPASS                                                    1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A0038, 0x00000008U ,0x00000008U)  */
    mask_write 0XFD1A0038 0x00000008 0x00000008
		# : ASSERT RESET
		# Register : VPLL_CTRL @ 0XFD1A0038</p>

		# Asserts Reset to the PLL. When asserting reset, the PLL must already be
    # in BYPASS.
		# PSU_CRF_APB_VPLL_CTRL_RESET                                                     1

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A0038, 0x00000001U ,0x00000001U)  */
    mask_write 0XFD1A0038 0x00000001 0x00000001
		# : DEASSERT RESET
		# Register : VPLL_CTRL @ 0XFD1A0038</p>

		# Asserts Reset to the PLL. When asserting reset, the PLL must already be
    # in BYPASS.
		# PSU_CRF_APB_VPLL_CTRL_RESET                                                     0

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A0038, 0x00000001U ,0x00000000U)  */
    mask_write 0XFD1A0038 0x00000001 0x00000000
		# : CHECK PLL STATUS
		# Register : PLL_STATUS @ 0XFD1A0044</p>

		# VPLL is locked
		# PSU_CRF_APB_PLL_STATUS_VPLL_LOCK                                                1
    mask_poll 0XFD1A0044 0x00000004
		# : REMOVE PLL BY PASS
		# Register : VPLL_CTRL @ 0XFD1A0038</p>

		# Bypasses the PLL clock. The usable clock will be determined from the POS
    # T_SRC field. (This signal may only be toggled after 4 cycles of the old
    # clock and 4 cycles of the new clock. This is not usually an issue, but d
    # esigners must be aware.)
		# PSU_CRF_APB_VPLL_CTRL_BYPASS                                                    0

		# PLL Basic Control
		#(OFFSET, MASK, VALUE)      (0XFD1A0038, 0x00000008U ,0x00000000U)  */
    mask_write 0XFD1A0038 0x00000008 0x00000000
		# Register : VPLL_TO_LPD_CTRL @ 0XFD1A0050</p>

		# Divisor value for this clock.
		# PSU_CRF_APB_VPLL_TO_LPD_CTRL_DIVISOR0                                           0x2

		# Control for a clock that will be generated in the FPD, but used in the L
    # PD as a clock source for the peripheral clock muxes.
		#(OFFSET, MASK, VALUE)      (0XFD1A0050, 0x00003F00U ,0x00000200U)  */
    mask_write 0XFD1A0050 0x00003F00 0x00000200
		# : VIDEO FRAC CFG
}

set psu_clock_init_data {
		# : CLOCK CONTROL SLCR REGISTER
		# Register : USB0_BUS_REF_CTRL @ 0XFF5E0060</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_USB0_BUS_REF_CTRL_CLKACT                                            0x1

		# 6 bit divider
		# PSU_CRL_APB_USB0_BUS_REF_CTRL_DIVISOR1                                          0x1

		# 6 bit divider
		# PSU_CRL_APB_USB0_BUS_REF_CTRL_DIVISOR0                                          0x6

		# 000 = IOPLL; 010 = RPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_USB0_BUS_REF_CTRL_SRCSEL                                            0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E0060, 0x023F3F07U ,0x02010600U)  */
    mask_write 0XFF5E0060 0x023F3F07 0x02010600
		# Register : USB3_DUAL_REF_CTRL @ 0XFF5E004C</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_USB3_DUAL_REF_CTRL_CLKACT                                           0x1

		# 6 bit divider
		# PSU_CRL_APB_USB3_DUAL_REF_CTRL_DIVISOR1                                         0x3

		# 6 bit divider
		# PSU_CRL_APB_USB3_DUAL_REF_CTRL_DIVISOR0                                         0x19

		# 000 = IOPLL; 010 = RPLL; 011 = DPLL. (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_USB3_DUAL_REF_CTRL_SRCSEL                                           0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E004C, 0x023F3F07U ,0x02031900U)  */
    mask_write 0XFF5E004C 0x023F3F07 0x02031900
		# Register : QSPI_REF_CTRL @ 0XFF5E0068</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_QSPI_REF_CTRL_CLKACT                                                0x1

		# 6 bit divider
		# PSU_CRL_APB_QSPI_REF_CTRL_DIVISOR1                                              0x1

		# 6 bit divider
		# PSU_CRL_APB_QSPI_REF_CTRL_DIVISOR0                                              0xc

		# 000 = IOPLL; 010 = RPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_QSPI_REF_CTRL_SRCSEL                                                0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E0068, 0x013F3F07U ,0x01010C00U)  */
    mask_write 0XFF5E0068 0x013F3F07 0x01010C00
		# Register : SDIO0_REF_CTRL @ 0XFF5E006C</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_SDIO0_REF_CTRL_CLKACT                                               0x1

		# 6 bit divider
		# PSU_CRL_APB_SDIO0_REF_CTRL_DIVISOR1                                             0x1

		# 6 bit divider
		# PSU_CRL_APB_SDIO0_REF_CTRL_DIVISOR0                                             0x6

		# 000 = IOPLL; 010 = RPLL; 011 = VPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_SDIO0_REF_CTRL_SRCSEL                                               0x2

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E006C, 0x013F3F07U ,0x01010602U)  */
    mask_write 0XFF5E006C 0x013F3F07 0x01010602
		# Register : SDIO_CLK_CTRL @ 0XFF18030C</p>

		# MIO pad selection for sdio0_rx_clk (feedback clock from the PAD) 00: MIO
    #  [22] 01: MIO [38] 10: MIO [64] 11: MIO [64]
		# PSU_IOU_SLCR_SDIO_CLK_CTRL_SDIO0_RX_SRC_SEL                                     0

		# SoC Debug Clock Control
		#(OFFSET, MASK, VALUE)      (0XFF18030C, 0x00000003U ,0x00000000U)  */
    mask_write 0XFF18030C 0x00000003 0x00000000
		# Register : UART0_REF_CTRL @ 0XFF5E0074</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_UART0_REF_CTRL_CLKACT                                               0x1

		# 6 bit divider
		# PSU_CRL_APB_UART0_REF_CTRL_DIVISOR1                                             0x1

		# 6 bit divider
		# PSU_CRL_APB_UART0_REF_CTRL_DIVISOR0                                             0xf

		# 000 = IOPLL; 010 = RPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_UART0_REF_CTRL_SRCSEL                                               0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E0074, 0x013F3F07U ,0x01010F00U)  */
    mask_write 0XFF5E0074 0x013F3F07 0x01010F00
		# Register : UART1_REF_CTRL @ 0XFF5E0078</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_UART1_REF_CTRL_CLKACT                                               0x1

		# 6 bit divider
		# PSU_CRL_APB_UART1_REF_CTRL_DIVISOR1                                             0x1

		# 6 bit divider
		# PSU_CRL_APB_UART1_REF_CTRL_DIVISOR0                                             0xf

		# 000 = IOPLL; 010 = RPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_UART1_REF_CTRL_SRCSEL                                               0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E0078, 0x013F3F07U ,0x01010F00U)  */
    mask_write 0XFF5E0078 0x013F3F07 0x01010F00
		# Register : I2C0_REF_CTRL @ 0XFF5E0120</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_I2C0_REF_CTRL_CLKACT                                                0x1

		# 6 bit divider
		# PSU_CRL_APB_I2C0_REF_CTRL_DIVISOR1                                              0x1

		# 6 bit divider
		# PSU_CRL_APB_I2C0_REF_CTRL_DIVISOR0                                              0xf

		# 000 = IOPLL; 010 = RPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_I2C0_REF_CTRL_SRCSEL                                                0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E0120, 0x013F3F07U ,0x01010F00U)  */
    mask_write 0XFF5E0120 0x013F3F07 0x01010F00
		# Register : CPU_R5_CTRL @ 0XFF5E0090</p>

		# Turing this off will shut down the OCM, some parts of the APM, and preve
    # nt transactions going from the FPD to the LPD and could lead to system h
    # ang
		# PSU_CRL_APB_CPU_R5_CTRL_CLKACT                                                  0x1

		# 6 bit divider
		# PSU_CRL_APB_CPU_R5_CTRL_DIVISOR0                                                0x2

		# 000 = RPLL; 010 = IOPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_CPU_R5_CTRL_SRCSEL                                                  0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E0090, 0x01003F07U ,0x01000200U)  */
    mask_write 0XFF5E0090 0x01003F07 0x01000200
		# Register : IOU_SWITCH_CTRL @ 0XFF5E009C</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_IOU_SWITCH_CTRL_CLKACT                                              0x1

		# 6 bit divider
		# PSU_CRL_APB_IOU_SWITCH_CTRL_DIVISOR0                                            0x4

		# 000 = RPLL; 010 = IOPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_IOU_SWITCH_CTRL_SRCSEL                                              0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E009C, 0x01003F07U ,0x01000400U)  */
    mask_write 0XFF5E009C 0x01003F07 0x01000400
		# Register : PCAP_CTRL @ 0XFF5E00A4</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_PCAP_CTRL_CLKACT                                                    0x1

		# 6 bit divider
		# PSU_CRL_APB_PCAP_CTRL_DIVISOR0                                                  0x8

		# 000 = IOPLL; 010 = RPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_PCAP_CTRL_SRCSEL                                                    0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E00A4, 0x01003F07U ,0x01000800U)  */
    mask_write 0XFF5E00A4 0x01003F07 0x01000800
		# Register : LPD_SWITCH_CTRL @ 0XFF5E00A8</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_LPD_SWITCH_CTRL_CLKACT                                              0x1

		# 6 bit divider
		# PSU_CRL_APB_LPD_SWITCH_CTRL_DIVISOR0                                            0x2

		# 000 = RPLL; 010 = IOPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_LPD_SWITCH_CTRL_SRCSEL                                              0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E00A8, 0x01003F07U ,0x01000200U)  */
    mask_write 0XFF5E00A8 0x01003F07 0x01000200
		# Register : LPD_LSBUS_CTRL @ 0XFF5E00AC</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_LPD_LSBUS_CTRL_CLKACT                                               0x1

		# 6 bit divider
		# PSU_CRL_APB_LPD_LSBUS_CTRL_DIVISOR0                                             0xf

		# 000 = RPLL; 010 = IOPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_LPD_LSBUS_CTRL_SRCSEL                                               0x2

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E00AC, 0x01003F07U ,0x01000F02U)  */
    mask_write 0XFF5E00AC 0x01003F07 0x01000F02
		# Register : DBG_LPD_CTRL @ 0XFF5E00B0</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_DBG_LPD_CTRL_CLKACT                                                 0x1

		# 6 bit divider
		# PSU_CRL_APB_DBG_LPD_CTRL_DIVISOR0                                               0x6

		# 000 = RPLL; 010 = IOPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_DBG_LPD_CTRL_SRCSEL                                                 0x2

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E00B0, 0x01003F07U ,0x01000602U)  */
    mask_write 0XFF5E00B0 0x01003F07 0x01000602
		# Register : ADMA_REF_CTRL @ 0XFF5E00B8</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_ADMA_REF_CTRL_CLKACT                                                0x1

		# 6 bit divider
		# PSU_CRL_APB_ADMA_REF_CTRL_DIVISOR0                                              0x2

		# 000 = RPLL; 010 = IOPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_ADMA_REF_CTRL_SRCSEL                                                0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E00B8, 0x01003F07U ,0x01000200U)  */
    mask_write 0XFF5E00B8 0x01003F07 0x01000200
		# Register : PL0_REF_CTRL @ 0XFF5E00C0</p>

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_PL0_REF_CTRL_CLKACT                                                 0x1

		# 6 bit divider
		# PSU_CRL_APB_PL0_REF_CTRL_DIVISOR1                                               0x1

		# 6 bit divider
		# PSU_CRL_APB_PL0_REF_CTRL_DIVISOR0                                               0xf

		# 000 = IOPLL; 010 = RPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_PL0_REF_CTRL_SRCSEL                                                 0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E00C0, 0x013F3F07U ,0x01010F00U)  */
    mask_write 0XFF5E00C0 0x013F3F07 0x01010F00
		# Register : AMS_REF_CTRL @ 0XFF5E0108</p>

		# 6 bit divider
		# PSU_CRL_APB_AMS_REF_CTRL_DIVISOR1                                               0x1

		# 6 bit divider
		# PSU_CRL_APB_AMS_REF_CTRL_DIVISOR0                                               0x1e

		# 000 = RPLL; 010 = IOPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_AMS_REF_CTRL_SRCSEL                                                 0x2

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_AMS_REF_CTRL_CLKACT                                                 0x1

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E0108, 0x013F3F07U ,0x01011E02U)  */
    mask_write 0XFF5E0108 0x013F3F07 0x01011E02
		# Register : DLL_REF_CTRL @ 0XFF5E0104</p>

		# 000 = IOPLL; 001 = RPLL; (This signal may only be toggled after 4 cycles
    #  of the old clock and 4 cycles of the new clock. This is not usually an
    # issue, but designers must be aware.)
		# PSU_CRL_APB_DLL_REF_CTRL_SRCSEL                                                 0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E0104, 0x00000007U ,0x00000000U)  */
    mask_write 0XFF5E0104 0x00000007 0x00000000
		# Register : TIMESTAMP_REF_CTRL @ 0XFF5E0128</p>

		# 6 bit divider
		# PSU_CRL_APB_TIMESTAMP_REF_CTRL_DIVISOR0                                         1

		# 1XX = pss_ref_clk; 000 = IOPLL; 010 = RPLL; 011 = DPLL; (This signal may
    #  only be toggled after 4 cycles of the old clock and 4 cycles of the new
    #  clock. This is not usually an issue, but designers must be aware.)
		# PSU_CRL_APB_TIMESTAMP_REF_CTRL_SRCSEL                                           4

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_TIMESTAMP_REF_CTRL_CLKACT                                           1

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E0128, 0x01003F07U ,0x01000104U)  */
    mask_write 0XFF5E0128 0x01003F07 0x01000104
		# Register : PCIE_REF_CTRL @ 0XFD1A00B4</p>

		# 000 = IOPLL_TO_FPD; 010 = RPLL_TO_FPD; 011 = DPLL; (This signal may only
    #  be toggled after 4 cycles of the old clock and 4 cycles of the new cloc
    # k. This is not usually an issue, but designers must be aware.)
		# PSU_CRF_APB_PCIE_REF_CTRL_SRCSEL                                                0x0

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRF_APB_PCIE_REF_CTRL_CLKACT                                                0x1

		# 6 bit divider
		# PSU_CRF_APB_PCIE_REF_CTRL_DIVISOR0                                              0x2

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFD1A00B4, 0x01003F07U ,0x01000200U)  */
    mask_write 0XFD1A00B4 0x01003F07 0x01000200
		# Register : ACPU_CTRL @ 0XFD1A0060</p>

		# 6 bit divider
		# PSU_CRF_APB_ACPU_CTRL_DIVISOR0                                                  0x1

		# 000 = APLL; 010 = DPLL; 011 = VPLL; (This signal may only be toggled aft
    # er 4 cycles of the old clock and 4 cycles of the new clock. This is not
    # usually an issue, but designers must be aware.)
		# PSU_CRF_APB_ACPU_CTRL_SRCSEL                                                    0x0

		# Clock active signal. Switch to 0 to disable the clock. For the half spee
    # d APU Clock
		# PSU_CRF_APB_ACPU_CTRL_CLKACT_HALF                                               0x1

		# Clock active signal. Switch to 0 to disable the clock. For the full spee
    # d ACPUX Clock. This will shut off the high speed clock to the entire APU
		# PSU_CRF_APB_ACPU_CTRL_CLKACT_FULL                                               0x1

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFD1A0060, 0x03003F07U ,0x03000100U)  */
    mask_write 0XFD1A0060 0x03003F07 0x03000100
		# Register : DBG_FPD_CTRL @ 0XFD1A0068</p>

		# 6 bit divider
		# PSU_CRF_APB_DBG_FPD_CTRL_DIVISOR0                                               0x2

		# 000 = IOPLL_TO_FPD; 010 = DPLL; 011 = APLL; (This signal may only be tog
    # gled after 4 cycles of the old clock and 4 cycles of the new clock. This
    #  is not usually an issue, but designers must be aware.)
		# PSU_CRF_APB_DBG_FPD_CTRL_SRCSEL                                                 0x0

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRF_APB_DBG_FPD_CTRL_CLKACT                                                 0x1

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFD1A0068, 0x01003F07U ,0x01000200U)  */
    mask_write 0XFD1A0068 0x01003F07 0x01000200
		# Register : DDR_CTRL @ 0XFD1A0080</p>

		# 6 bit divider
		# PSU_CRF_APB_DDR_CTRL_DIVISOR0                                                   0x3

		# 000 = DPLL; 001 = VPLL; (This signal may only be toggled after 4 cycles
    # of the old clock and 4 cycles of the new clock. This is not usually an i
    # ssue, but designers must be aware.)
		# PSU_CRF_APB_DDR_CTRL_SRCSEL                                                     0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFD1A0080, 0x00003F07U ,0x00000300U)  */
    mask_write 0XFD1A0080 0x00003F07 0x00000300
		# Register : GPU_REF_CTRL @ 0XFD1A0084</p>

		# 6 bit divider
		# PSU_CRF_APB_GPU_REF_CTRL_DIVISOR0                                               0x2

		# 000 = IOPLL_TO_FPD; 010 = VPLL; 011 = DPLL; (This signal may only be tog
    # gled after 4 cycles of the old clock and 4 cycles of the new clock. This
    #  is not usually an issue, but designers must be aware.)
		# PSU_CRF_APB_GPU_REF_CTRL_SRCSEL                                                 0x3

		# Clock active signal. Switch to 0 to disable the clock, which will stop c
    # lock for GPU (and both Pixel Processors).
		# PSU_CRF_APB_GPU_REF_CTRL_CLKACT                                                 0x1

		# Clock active signal for Pixel Processor. Switch to 0 to disable the cloc
    # k only to this Pixel Processor
		# PSU_CRF_APB_GPU_REF_CTRL_PP0_CLKACT                                             0x1

		# Clock active signal for Pixel Processor. Switch to 0 to disable the cloc
    # k only to this Pixel Processor
		# PSU_CRF_APB_GPU_REF_CTRL_PP1_CLKACT                                             0x1

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFD1A0084, 0x07003F07U ,0x07000203U)  */
    mask_write 0XFD1A0084 0x07003F07 0x07000203
		# Register : GDMA_REF_CTRL @ 0XFD1A00B8</p>

		# 6 bit divider
		# PSU_CRF_APB_GDMA_REF_CTRL_DIVISOR0                                              0x2

		# 000 = APLL; 010 = VPLL; 011 = DPLL; (This signal may only be toggled aft
    # er 4 cycles of the old clock and 4 cycles of the new clock. This is not
    # usually an issue, but designers must be aware.)
		# PSU_CRF_APB_GDMA_REF_CTRL_SRCSEL                                                0x3

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRF_APB_GDMA_REF_CTRL_CLKACT                                                0x1

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFD1A00B8, 0x01003F07U ,0x01000203U)  */
    mask_write 0XFD1A00B8 0x01003F07 0x01000203
		# Register : DPDMA_REF_CTRL @ 0XFD1A00BC</p>

		# 6 bit divider
		# PSU_CRF_APB_DPDMA_REF_CTRL_DIVISOR0                                             0x2

		# 000 = APLL; 010 = VPLL; 011 = DPLL; (This signal may only be toggled aft
    # er 4 cycles of the old clock and 4 cycles of the new clock. This is not
    # usually an issue, but designers must be aware.)
		# PSU_CRF_APB_DPDMA_REF_CTRL_SRCSEL                                               0x3

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRF_APB_DPDMA_REF_CTRL_CLKACT                                               0x1

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFD1A00BC, 0x01003F07U ,0x01000203U)  */
    mask_write 0XFD1A00BC 0x01003F07 0x01000203
		# Register : TOPSW_MAIN_CTRL @ 0XFD1A00C0</p>

		# 6 bit divider
		# PSU_CRF_APB_TOPSW_MAIN_CTRL_DIVISOR0                                            0x2

		# 000 = APLL; 010 = VPLL; 011 = DPLL; (This signal may only be toggled aft
    # er 4 cycles of the old clock and 4 cycles of the new clock. This is not
    # usually an issue, but designers must be aware.)
		# PSU_CRF_APB_TOPSW_MAIN_CTRL_SRCSEL                                              0x2

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRF_APB_TOPSW_MAIN_CTRL_CLKACT                                              0x1

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFD1A00C0, 0x01003F07U ,0x01000202U)  */
    mask_write 0XFD1A00C0 0x01003F07 0x01000202
		# Register : TOPSW_LSBUS_CTRL @ 0XFD1A00C4</p>

		# 6 bit divider
		# PSU_CRF_APB_TOPSW_LSBUS_CTRL_DIVISOR0                                           0x5

		# 000 = APLL; 010 = IOPLL_TO_FPD; 011 = DPLL; (This signal may only be tog
    # gled after 4 cycles of the old clock and 4 cycles of the new clock. This
    #  is not usually an issue, but designers must be aware.)
		# PSU_CRF_APB_TOPSW_LSBUS_CTRL_SRCSEL                                             0x2

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRF_APB_TOPSW_LSBUS_CTRL_CLKACT                                             0x1

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFD1A00C4, 0x01003F07U ,0x01000502U)  */
    mask_write 0XFD1A00C4 0x01003F07 0x01000502
		# Register : DBG_TSTMP_CTRL @ 0XFD1A00F8</p>

		# 6 bit divider
		# PSU_CRF_APB_DBG_TSTMP_CTRL_DIVISOR0                                             0x2

		# 000 = IOPLL_TO_FPD; 010 = DPLL; 011 = APLL; (This signal may only be tog
    # gled after 4 cycles of the old clock and 4 cycles of the new clock. This
    #  is not usually an issue, but designers must be aware.)
		# PSU_CRF_APB_DBG_TSTMP_CTRL_SRCSEL                                               0x0

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFD1A00F8, 0x00003F07U ,0x00000200U)  */
    mask_write 0XFD1A00F8 0x00003F07 0x00000200
		# Register : IOU_TTC_APB_CLK @ 0XFF180380</p>

		# 00" = Select the APB switch clock for the APB interface of TTC0'01" = Se
    # lect the PLL ref clock for the APB interface of TTC0'10" = Select the R5
    #  clock for the APB interface of TTC0
		# PSU_IOU_SLCR_IOU_TTC_APB_CLK_TTC0_SEL                                           0

		# 00" = Select the APB switch clock for the APB interface of TTC1'01" = Se
    # lect the PLL ref clock for the APB interface of TTC1'10" = Select the R5
    #  clock for the APB interface of TTC1
		# PSU_IOU_SLCR_IOU_TTC_APB_CLK_TTC1_SEL                                           0

		# 00" = Select the APB switch clock for the APB interface of TTC2'01" = Se
    # lect the PLL ref clock for the APB interface of TTC2'10" = Select the R5
    #  clock for the APB interface of TTC2
		# PSU_IOU_SLCR_IOU_TTC_APB_CLK_TTC2_SEL                                           0

		# 00" = Select the APB switch clock for the APB interface of TTC3'01" = Se
    # lect the PLL ref clock for the APB interface of TTC3'10" = Select the R5
    #  clock for the APB interface of TTC3
		# PSU_IOU_SLCR_IOU_TTC_APB_CLK_TTC3_SEL                                           0

		# TTC APB clock select
		#(OFFSET, MASK, VALUE)      (0XFF180380, 0x000000FFU ,0x00000000U)  */
    mask_write 0XFF180380 0x000000FF 0x00000000
		# Register : WDT_CLK_SEL @ 0XFD610100</p>

		# System watchdog timer clock source selection: 0: Internal APB clock 1: E
    # xternal (PL clock via EMIO or Pinout clock via MIO)
		# PSU_FPD_SLCR_WDT_CLK_SEL_SELECT                                                 0

		# SWDT clock source select
		#(OFFSET, MASK, VALUE)      (0XFD610100, 0x00000001U ,0x00000000U)  */
    mask_write 0XFD610100 0x00000001 0x00000000
		# Register : WDT_CLK_SEL @ 0XFF180300</p>

		# System watchdog timer clock source selection: 0: internal clock APB cloc
    # k 1: external clock from PL via EMIO, or from pinout via MIO
		# PSU_IOU_SLCR_WDT_CLK_SEL_SELECT                                                 0

		# SWDT clock source select
		#(OFFSET, MASK, VALUE)      (0XFF180300, 0x00000001U ,0x00000000U)  */
    mask_write 0XFF180300 0x00000001 0x00000000
		# Register : CSUPMU_WDT_CLK_SEL @ 0XFF410050</p>

		# System watchdog timer clock source selection: 0: internal clock APB cloc
    # k 1: external clock pss_ref_clk
		# PSU_LPD_SLCR_CSUPMU_WDT_CLK_SEL_SELECT                                          0

		# SWDT clock source select
		#(OFFSET, MASK, VALUE)      (0XFF410050, 0x00000001U ,0x00000000U)  */
    mask_write 0XFF410050 0x00000001 0x00000000
}

set psu_ddr_qos_init_data {
		# : AFI INTERCONNECT QOS CONFIGURATION
}

set psu_mio_init_data {
		# : MIO PROGRAMMING
		# Register : MIO_PIN_0 @ 0XFF180000</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= qspi, Output, qspi_sclk_out-
    #  (QSPI Clock)
		# PSU_IOU_SLCR_MIO_PIN_0_L0_SEL                                                   1

		# Level 1 Mux Select 0= Level 2 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_0_L1_SEL                                                   0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= test_scan, Input
    # , test_scan_in[0]- (Test Scan Port) = test_scan, Output, test_scan_out[0
    # ]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_0_L2_SEL                                                   0

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[0]- (GPIO bank 0) 0= g
    # pio0, Output, gpio_0_pin_out[0]- (GPIO bank 0) 1= can1, Output, can1_phy
    # _tx- (Can TX signal) 2= i2c1, Input, i2c1_scl_input- (SCL signal) 2= i2c
    # 1, Output, i2c1_scl_out- (SCL signal) 3= pjtag, Input, pjtag_tck- (PJTAG
    #  TCK) 4= spi0, Input, spi0_sclk_in- (SPI Clock) 4= spi0, Output, spi0_sc
    # lk_out- (SPI Clock) 5= ttc3, Input, ttc3_clk_in- (TTC Clock) 6= ua1, Out
    # put, ua1_txd- (UART transmitter serial output) 7= trace, Output, trace_c
    # lk- (Trace Port Clock)
		# PSU_IOU_SLCR_MIO_PIN_0_L3_SEL                                                   0

		# Configures MIO Pin 0 peripheral interface mapping. S
		#(OFFSET, MASK, VALUE)      (0XFF180000, 0x000000FEU ,0x00000002U)  */
    mask_write 0XFF180000 0x000000FE 0x00000002
		# Register : MIO_PIN_1 @ 0XFF180004</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= qspi, Input, qspi_mi_mi1- (Q
    # SPI Databus) 1= qspi, Output, qspi_so_mo1- (QSPI Databus)
		# PSU_IOU_SLCR_MIO_PIN_1_L0_SEL                                                   1

		# Level 1 Mux Select 0= Level 2 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_1_L1_SEL                                                   0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= test_scan, Input
    # , test_scan_in[1]- (Test Scan Port) = test_scan, Output, test_scan_out[1
    # ]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_1_L2_SEL                                                   0

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[1]- (GPIO bank 0) 0= g
    # pio0, Output, gpio_0_pin_out[1]- (GPIO bank 0) 1= can1, Input, can1_phy_
    # rx- (Can RX signal) 2= i2c1, Input, i2c1_sda_input- (SDA signal) 2= i2c1
    # , Output, i2c1_sda_out- (SDA signal) 3= pjtag, Input, pjtag_tdi- (PJTAG
    # TDI) 4= spi0, Output, spi0_n_ss_out[2]- (SPI Master Selects) 5= ttc3, Ou
    # tput, ttc3_wave_out- (TTC Waveform Clock) 6= ua1, Input, ua1_rxd- (UART
    # receiver serial input) 7= trace, Output, trace_ctl- (Trace Port Control
    # Signal)
		# PSU_IOU_SLCR_MIO_PIN_1_L3_SEL                                                   0

		# Configures MIO Pin 1 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180004, 0x000000FEU ,0x00000002U)  */
    mask_write 0XFF180004 0x000000FE 0x00000002
		# Register : MIO_PIN_2 @ 0XFF180008</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= qspi, Input, qspi_mi2- (QSPI
    #  Databus) 1= qspi, Output, qspi_mo2- (QSPI Databus)
		# PSU_IOU_SLCR_MIO_PIN_2_L0_SEL                                                   1

		# Level 1 Mux Select 0= Level 2 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_2_L1_SEL                                                   0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= test_scan, Input
    # , test_scan_in[2]- (Test Scan Port) = test_scan, Output, test_scan_out[2
    # ]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_2_L2_SEL                                                   0

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[2]- (GPIO bank 0) 0= g
    # pio0, Output, gpio_0_pin_out[2]- (GPIO bank 0) 1= can0, Input, can0_phy_
    # rx- (Can RX signal) 2= i2c0, Input, i2c0_scl_input- (SCL signal) 2= i2c0
    # , Output, i2c0_scl_out- (SCL signal) 3= pjtag, Output, pjtag_tdo- (PJTAG
    #  TDO) 4= spi0, Output, spi0_n_ss_out[1]- (SPI Master Selects) 5= ttc2, I
    # nput, ttc2_clk_in- (TTC Clock) 6= ua0, Input, ua0_rxd- (UART receiver se
    # rial input) 7= trace, Output, tracedq[0]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_2_L3_SEL                                                   0

		# Configures MIO Pin 2 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180008, 0x000000FEU ,0x00000002U)  */
    mask_write 0XFF180008 0x000000FE 0x00000002
		# Register : MIO_PIN_3 @ 0XFF18000C</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= qspi, Input, qspi_mi3- (QSPI
    #  Databus) 1= qspi, Output, qspi_mo3- (QSPI Databus)
		# PSU_IOU_SLCR_MIO_PIN_3_L0_SEL                                                   1

		# Level 1 Mux Select 0= Level 2 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_3_L1_SEL                                                   0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= test_scan, Input
    # , test_scan_in[3]- (Test Scan Port) = test_scan, Output, test_scan_out[3
    # ]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_3_L2_SEL                                                   0

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[3]- (GPIO bank 0) 0= g
    # pio0, Output, gpio_0_pin_out[3]- (GPIO bank 0) 1= can0, Output, can0_phy
    # _tx- (Can TX signal) 2= i2c0, Input, i2c0_sda_input- (SDA signal) 2= i2c
    # 0, Output, i2c0_sda_out- (SDA signal) 3= pjtag, Input, pjtag_tms- (PJTAG
    #  TMS) 4= spi0, Input, spi0_n_ss_in- (SPI Master Selects) 4= spi0, Output
    # , spi0_n_ss_out[0]- (SPI Master Selects) 5= ttc2, Output, ttc2_wave_out-
    #  (TTC Waveform Clock) 6= ua0, Output, ua0_txd- (UART transmitter serial
    # output) 7= trace, Output, tracedq[1]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_3_L3_SEL                                                   0

		# Configures MIO Pin 3 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF18000C, 0x000000FEU ,0x00000002U)  */
    mask_write 0XFF18000C 0x000000FE 0x00000002
		# Register : MIO_PIN_4 @ 0XFF180010</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= qspi, Output, qspi_mo_mo0- (
    # QSPI Databus) 1= qspi, Input, qspi_si_mi0- (QSPI Databus)
		# PSU_IOU_SLCR_MIO_PIN_4_L0_SEL                                                   1

		# Level 1 Mux Select 0= Level 2 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_4_L1_SEL                                                   0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= test_scan, Input
    # , test_scan_in[4]- (Test Scan Port) = test_scan, Output, test_scan_out[4
    # ]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_4_L2_SEL                                                   0

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[4]- (GPIO bank 0) 0= g
    # pio0, Output, gpio_0_pin_out[4]- (GPIO bank 0) 1= can1, Output, can1_phy
    # _tx- (Can TX signal) 2= i2c1, Input, i2c1_scl_input- (SCL signal) 2= i2c
    # 1, Output, i2c1_scl_out- (SCL signal) 3= swdt1, Input, swdt1_clk_in- (Wa
    # tch Dog Timer Input clock) 4= spi0, Input, spi0_mi- (MISO signal) 4= spi
    # 0, Output, spi0_so- (MISO signal) 5= ttc1, Input, ttc1_clk_in- (TTC Cloc
    # k) 6= ua1, Output, ua1_txd- (UART transmitter serial output) 7= trace, O
    # utput, tracedq[2]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_4_L3_SEL                                                   0

		# Configures MIO Pin 4 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180010, 0x000000FEU ,0x00000002U)  */
    mask_write 0XFF180010 0x000000FE 0x00000002
		# Register : MIO_PIN_5 @ 0XFF180014</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= qspi, Output, qspi_n_ss_out-
    #  (QSPI Slave Select)
		# PSU_IOU_SLCR_MIO_PIN_5_L0_SEL                                                   1

		# Level 1 Mux Select 0= Level 2 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_5_L1_SEL                                                   0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= test_scan, Input
    # , test_scan_in[5]- (Test Scan Port) = test_scan, Output, test_scan_out[5
    # ]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_5_L2_SEL                                                   0

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[5]- (GPIO bank 0) 0= g
    # pio0, Output, gpio_0_pin_out[5]- (GPIO bank 0) 1= can1, Input, can1_phy_
    # rx- (Can RX signal) 2= i2c1, Input, i2c1_sda_input- (SDA signal) 2= i2c1
    # , Output, i2c1_sda_out- (SDA signal) 3= swdt1, Output, swdt1_rst_out- (W
    # atch Dog Timer Output clock) 4= spi0, Output, spi0_mo- (MOSI signal) 4=
    # spi0, Input, spi0_si- (MOSI signal) 5= ttc1, Output, ttc1_wave_out- (TTC
    #  Waveform Clock) 6= ua1, Input, ua1_rxd- (UART receiver serial input) 7=
    #  trace, Output, tracedq[3]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_5_L3_SEL                                                   0

		# Configures MIO Pin 5 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180014, 0x000000FEU ,0x00000002U)  */
    mask_write 0XFF180014 0x000000FE 0x00000002
		# Register : MIO_PIN_6 @ 0XFF180018</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= qspi, Output, qspi_clk_for_l
    # pbk- (QSPI Clock to be fed-back)
		# PSU_IOU_SLCR_MIO_PIN_6_L0_SEL                                                   1

		# Level 1 Mux Select 0= Level 2 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_6_L1_SEL                                                   0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= test_scan, Input
    # , test_scan_in[6]- (Test Scan Port) = test_scan, Output, test_scan_out[6
    # ]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_6_L2_SEL                                                   0

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[6]- (GPIO bank 0) 0= g
    # pio0, Output, gpio_0_pin_out[6]- (GPIO bank 0) 1= can0, Input, can0_phy_
    # rx- (Can RX signal) 2= i2c0, Input, i2c0_scl_input- (SCL signal) 2= i2c0
    # , Output, i2c0_scl_out- (SCL signal) 3= swdt0, Input, swdt0_clk_in- (Wat
    # ch Dog Timer Input clock) 4= spi1, Input, spi1_sclk_in- (SPI Clock) 4= s
    # pi1, Output, spi1_sclk_out- (SPI Clock) 5= ttc0, Input, ttc0_clk_in- (TT
    # C Clock) 6= ua0, Input, ua0_rxd- (UART receiver serial input) 7= trace,
    # Output, tracedq[4]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_6_L3_SEL                                                   0

		# Configures MIO Pin 6 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180018, 0x000000FEU ,0x00000002U)  */
    mask_write 0XFF180018 0x000000FE 0x00000002
		# Register : MIO_PIN_13 @ 0XFF180034</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_13_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= nand, Output, nfc_ce[0]- (NA
    # ND chip enable)
		# PSU_IOU_SLCR_MIO_PIN_13_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_data_in[0]-
    # (8-bit Data bus) = sd0, Output, sdio0_data_out[0]- (8-bit Data bus) 2= t
    # est_scan, Input, test_scan_in[13]- (Test Scan Port) = test_scan, Output,
    #  test_scan_out[13]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_13_L2_SEL                                                  1

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[13]- (GPIO bank 0) 0=
    # gpio0, Output, gpio_0_pin_out[13]- (GPIO bank 0) 1= can1, Input, can1_ph
    # y_rx- (Can RX signal) 2= i2c1, Input, i2c1_sda_input- (SDA signal) 2= i2
    # c1, Output, i2c1_sda_out- (SDA signal) 3= pjtag, Input, pjtag_tdi- (PJTA
    # G TDI) 4= spi0, Output, spi0_n_ss_out[2]- (SPI Master Selects) 5= ttc1,
    # Output, ttc1_wave_out- (TTC Waveform Clock) 6= ua1, Input, ua1_rxd- (UAR
    # T receiver serial input) 7= trace, Output, tracedq[11]- (Trace Port Data
    # bus)
		# PSU_IOU_SLCR_MIO_PIN_13_L3_SEL                                                  0

		# Configures MIO Pin 13 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180034, 0x000000FEU ,0x00000008U)  */
    mask_write 0XFF180034 0x000000FE 0x00000008
		# Register : MIO_PIN_14 @ 0XFF180038</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_14_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= nand, Output, nfc_cle- (NAND
    #  Command Latch Enable)
		# PSU_IOU_SLCR_MIO_PIN_14_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_data_in[1]-
    # (8-bit Data bus) = sd0, Output, sdio0_data_out[1]- (8-bit Data bus) 2= t
    # est_scan, Input, test_scan_in[14]- (Test Scan Port) = test_scan, Output,
    #  test_scan_out[14]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_14_L2_SEL                                                  1

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[14]- (GPIO bank 0) 0=
    # gpio0, Output, gpio_0_pin_out[14]- (GPIO bank 0) 1= can0, Input, can0_ph
    # y_rx- (Can RX signal) 2= i2c0, Input, i2c0_scl_input- (SCL signal) 2= i2
    # c0, Output, i2c0_scl_out- (SCL signal) 3= pjtag, Output, pjtag_tdo- (PJT
    # AG TDO) 4= spi0, Output, spi0_n_ss_out[1]- (SPI Master Selects) 5= ttc0,
    #  Input, ttc0_clk_in- (TTC Clock) 6= ua0, Input, ua0_rxd- (UART receiver
    # serial input) 7= trace, Output, tracedq[12]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_14_L3_SEL                                                  0

		# Configures MIO Pin 14 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180038, 0x000000FEU ,0x00000008U)  */
    mask_write 0XFF180038 0x000000FE 0x00000008
		# Register : MIO_PIN_15 @ 0XFF18003C</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_15_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= nand, Output, nfc_ale- (NAND
    #  Address Latch Enable)
		# PSU_IOU_SLCR_MIO_PIN_15_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_data_in[2]-
    # (8-bit Data bus) = sd0, Output, sdio0_data_out[2]- (8-bit Data bus) 2= t
    # est_scan, Input, test_scan_in[15]- (Test Scan Port) = test_scan, Output,
    #  test_scan_out[15]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_15_L2_SEL                                                  1

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[15]- (GPIO bank 0) 0=
    # gpio0, Output, gpio_0_pin_out[15]- (GPIO bank 0) 1= can0, Output, can0_p
    # hy_tx- (Can TX signal) 2= i2c0, Input, i2c0_sda_input- (SDA signal) 2= i
    # 2c0, Output, i2c0_sda_out- (SDA signal) 3= pjtag, Input, pjtag_tms- (PJT
    # AG TMS) 4= spi0, Input, spi0_n_ss_in- (SPI Master Selects) 4= spi0, Outp
    # ut, spi0_n_ss_out[0]- (SPI Master Selects) 5= ttc0, Output, ttc0_wave_ou
    # t- (TTC Waveform Clock) 6= ua0, Output, ua0_txd- (UART transmitter seria
    # l output) 7= trace, Output, tracedq[13]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_15_L3_SEL                                                  0

		# Configures MIO Pin 15 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF18003C, 0x000000FEU ,0x00000008U)  */
    mask_write 0XFF18003C 0x000000FE 0x00000008
		# Register : MIO_PIN_16 @ 0XFF180040</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_16_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= nand, Input, nfc_dq_in[0]- (
    # NAND Data Bus) 1= nand, Output, nfc_dq_out[0]- (NAND Data Bus)
		# PSU_IOU_SLCR_MIO_PIN_16_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_data_in[3]-
    # (8-bit Data bus) = sd0, Output, sdio0_data_out[3]- (8-bit Data bus) 2= t
    # est_scan, Input, test_scan_in[16]- (Test Scan Port) = test_scan, Output,
    #  test_scan_out[16]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_16_L2_SEL                                                  1

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[16]- (GPIO bank 0) 0=
    # gpio0, Output, gpio_0_pin_out[16]- (GPIO bank 0) 1= can1, Output, can1_p
    # hy_tx- (Can TX signal) 2= i2c1, Input, i2c1_scl_input- (SCL signal) 2= i
    # 2c1, Output, i2c1_scl_out- (SCL signal) 3= swdt1, Input, swdt1_clk_in- (
    # Watch Dog Timer Input clock) 4= spi0, Input, spi0_mi- (MISO signal) 4= s
    # pi0, Output, spi0_so- (MISO signal) 5= ttc3, Input, ttc3_clk_in- (TTC Cl
    # ock) 6= ua1, Output, ua1_txd- (UART transmitter serial output) 7= trace,
    #  Output, tracedq[14]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_16_L3_SEL                                                  0

		# Configures MIO Pin 16 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180040, 0x000000FEU ,0x00000008U)  */
    mask_write 0XFF180040 0x000000FE 0x00000008
		# Register : MIO_PIN_17 @ 0XFF180044</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_17_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= nand, Input, nfc_dq_in[1]- (
    # NAND Data Bus) 1= nand, Output, nfc_dq_out[1]- (NAND Data Bus)
		# PSU_IOU_SLCR_MIO_PIN_17_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_data_in[4]-
    # (8-bit Data bus) = sd0, Output, sdio0_data_out[4]- (8-bit Data bus) 2= t
    # est_scan, Input, test_scan_in[17]- (Test Scan Port) = test_scan, Output,
    #  test_scan_out[17]- (Test Scan Port) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_17_L2_SEL                                                  1

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[17]- (GPIO bank 0) 0=
    # gpio0, Output, gpio_0_pin_out[17]- (GPIO bank 0) 1= can1, Input, can1_ph
    # y_rx- (Can RX signal) 2= i2c1, Input, i2c1_sda_input- (SDA signal) 2= i2
    # c1, Output, i2c1_sda_out- (SDA signal) 3= swdt1, Output, swdt1_rst_out-
    # (Watch Dog Timer Output clock) 4= spi0, Output, spi0_mo- (MOSI signal) 4
    # = spi0, Input, spi0_si- (MOSI signal) 5= ttc3, Output, ttc3_wave_out- (T
    # TC Waveform Clock) 6= ua1, Input, ua1_rxd- (UART receiver serial input)
    # 7= trace, Output, tracedq[15]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_17_L3_SEL                                                  0

		# Configures MIO Pin 17 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180044, 0x000000FEU ,0x00000008U)  */
    mask_write 0XFF180044 0x000000FE 0x00000008
		# Register : MIO_PIN_18 @ 0XFF180048</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_18_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= nand, Input, nfc_dq_in[2]- (
    # NAND Data Bus) 1= nand, Output, nfc_dq_out[2]- (NAND Data Bus)
		# PSU_IOU_SLCR_MIO_PIN_18_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_data_in[5]-
    # (8-bit Data bus) = sd0, Output, sdio0_data_out[5]- (8-bit Data bus) 2= t
    # est_scan, Input, test_scan_in[18]- (Test Scan Port) = test_scan, Output,
    #  test_scan_out[18]- (Test Scan Port) 3= csu, Input, csu_ext_tamper- (CSU
    #  Ext Tamper)
		# PSU_IOU_SLCR_MIO_PIN_18_L2_SEL                                                  1

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[18]- (GPIO bank 0) 0=
    # gpio0, Output, gpio_0_pin_out[18]- (GPIO bank 0) 1= can0, Input, can0_ph
    # y_rx- (Can RX signal) 2= i2c0, Input, i2c0_scl_input- (SCL signal) 2= i2
    # c0, Output, i2c0_scl_out- (SCL signal) 3= swdt0, Input, swdt0_clk_in- (W
    # atch Dog Timer Input clock) 4= spi1, Input, spi1_mi- (MISO signal) 4= sp
    # i1, Output, spi1_so- (MISO signal) 5= ttc2, Input, ttc2_clk_in- (TTC Clo
    # ck) 6= ua0, Input, ua0_rxd- (UART receiver serial input) 7= Not Used
		# PSU_IOU_SLCR_MIO_PIN_18_L3_SEL                                                  0

		# Configures MIO Pin 18 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180048, 0x000000FEU ,0x00000008U)  */
    mask_write 0XFF180048 0x000000FE 0x00000008
		# Register : MIO_PIN_19 @ 0XFF18004C</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_19_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= nand, Input, nfc_dq_in[3]- (
    # NAND Data Bus) 1= nand, Output, nfc_dq_out[3]- (NAND Data Bus)
		# PSU_IOU_SLCR_MIO_PIN_19_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_data_in[6]-
    # (8-bit Data bus) = sd0, Output, sdio0_data_out[6]- (8-bit Data bus) 2= t
    # est_scan, Input, test_scan_in[19]- (Test Scan Port) = test_scan, Output,
    #  test_scan_out[19]- (Test Scan Port) 3= csu, Input, csu_ext_tamper- (CSU
    #  Ext Tamper)
		# PSU_IOU_SLCR_MIO_PIN_19_L2_SEL                                                  1

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[19]- (GPIO bank 0) 0=
    # gpio0, Output, gpio_0_pin_out[19]- (GPIO bank 0) 1= can0, Output, can0_p
    # hy_tx- (Can TX signal) 2= i2c0, Input, i2c0_sda_input- (SDA signal) 2= i
    # 2c0, Output, i2c0_sda_out- (SDA signal) 3= swdt0, Output, swdt0_rst_out-
    #  (Watch Dog Timer Output clock) 4= spi1, Output, spi1_n_ss_out[2]- (SPI
    # Master Selects) 5= ttc2, Output, ttc2_wave_out- (TTC Waveform Clock) 6=
    # ua0, Output, ua0_txd- (UART transmitter serial output) 7= Not Used
		# PSU_IOU_SLCR_MIO_PIN_19_L3_SEL                                                  0

		# Configures MIO Pin 19 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF18004C, 0x000000FEU ,0x00000008U)  */
    mask_write 0XFF18004C 0x000000FE 0x00000008
		# Register : MIO_PIN_20 @ 0XFF180050</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_20_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= nand, Input, nfc_dq_in[4]- (
    # NAND Data Bus) 1= nand, Output, nfc_dq_out[4]- (NAND Data Bus)
		# PSU_IOU_SLCR_MIO_PIN_20_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_data_in[7]-
    # (8-bit Data bus) = sd0, Output, sdio0_data_out[7]- (8-bit Data bus) 2= t
    # est_scan, Input, test_scan_in[20]- (Test Scan Port) = test_scan, Output,
    #  test_scan_out[20]- (Test Scan Port) 3= csu, Input, csu_ext_tamper- (CSU
    #  Ext Tamper)
		# PSU_IOU_SLCR_MIO_PIN_20_L2_SEL                                                  1

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[20]- (GPIO bank 0) 0=
    # gpio0, Output, gpio_0_pin_out[20]- (GPIO bank 0) 1= can1, Output, can1_p
    # hy_tx- (Can TX signal) 2= i2c1, Input, i2c1_scl_input- (SCL signal) 2= i
    # 2c1, Output, i2c1_scl_out- (SCL signal) 3= swdt1, Input, swdt1_clk_in- (
    # Watch Dog Timer Input clock) 4= spi1, Output, spi1_n_ss_out[1]- (SPI Mas
    # ter Selects) 5= ttc1, Input, ttc1_clk_in- (TTC Clock) 6= ua1, Output, ua
    # 1_txd- (UART transmitter serial output) 7= Not Used
		# PSU_IOU_SLCR_MIO_PIN_20_L3_SEL                                                  0

		# Configures MIO Pin 20 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180050, 0x000000FEU ,0x00000008U)  */
    mask_write 0XFF180050 0x000000FE 0x00000008
		# Register : MIO_PIN_21 @ 0XFF180054</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_21_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= nand, Input, nfc_dq_in[5]- (
    # NAND Data Bus) 1= nand, Output, nfc_dq_out[5]- (NAND Data Bus)
		# PSU_IOU_SLCR_MIO_PIN_21_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_cmd_in- (Com
    # mand Indicator) = sd0, Output, sdio0_cmd_out- (Command Indicator) 2= tes
    # t_scan, Input, test_scan_in[21]- (Test Scan Port) = test_scan, Output, t
    # est_scan_out[21]- (Test Scan Port) 3= csu, Input, csu_ext_tamper- (CSU E
    # xt Tamper)
		# PSU_IOU_SLCR_MIO_PIN_21_L2_SEL                                                  1

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[21]- (GPIO bank 0) 0=
    # gpio0, Output, gpio_0_pin_out[21]- (GPIO bank 0) 1= can1, Input, can1_ph
    # y_rx- (Can RX signal) 2= i2c1, Input, i2c1_sda_input- (SDA signal) 2= i2
    # c1, Output, i2c1_sda_out- (SDA signal) 3= swdt1, Output, swdt1_rst_out-
    # (Watch Dog Timer Output clock) 4= spi1, Input, spi1_n_ss_in- (SPI Master
    #  Selects) 4= spi1, Output, spi1_n_ss_out[0]- (SPI Master Selects) 5= ttc
    # 1, Output, ttc1_wave_out- (TTC Waveform Clock) 6= ua1, Input, ua1_rxd- (
    # UART receiver serial input) 7= Not Used
		# PSU_IOU_SLCR_MIO_PIN_21_L3_SEL                                                  0

		# Configures MIO Pin 21 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180054, 0x000000FEU ,0x00000008U)  */
    mask_write 0XFF180054 0x000000FE 0x00000008
		# Register : MIO_PIN_22 @ 0XFF180058</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_22_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= nand, Output, nfc_we_b- (NAN
    # D Write Enable)
		# PSU_IOU_SLCR_MIO_PIN_22_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Output, sdio0_clk_out-
    # (SDSDIO clock) 2= test_scan, Input, test_scan_in[22]- (Test Scan Port) =
    #  test_scan, Output, test_scan_out[22]- (Test Scan Port) 3= csu, Input, c
    # su_ext_tamper- (CSU Ext Tamper)
		# PSU_IOU_SLCR_MIO_PIN_22_L2_SEL                                                  1

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[22]- (GPIO bank 0) 0=
    # gpio0, Output, gpio_0_pin_out[22]- (GPIO bank 0) 1= can0, Input, can0_ph
    # y_rx- (Can RX signal) 2= i2c0, Input, i2c0_scl_input- (SCL signal) 2= i2
    # c0, Output, i2c0_scl_out- (SCL signal) 3= swdt0, Input, swdt0_clk_in- (W
    # atch Dog Timer Input clock) 4= spi1, Input, spi1_sclk_in- (SPI Clock) 4=
    #  spi1, Output, spi1_sclk_out- (SPI Clock) 5= ttc0, Input, ttc0_clk_in- (
    # TTC Clock) 6= ua0, Input, ua0_rxd- (UART receiver serial input) 7= Not U
    # sed
		# PSU_IOU_SLCR_MIO_PIN_22_L3_SEL                                                  0

		# Configures MIO Pin 22 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180058, 0x000000FEU ,0x00000008U)  */
    mask_write 0XFF180058 0x000000FE 0x00000008
		# Register : MIO_PIN_23 @ 0XFF18005C</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_23_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= nand, Input, nfc_dq_in[6]- (
    # NAND Data Bus) 1= nand, Output, nfc_dq_out[6]- (NAND Data Bus)
		# PSU_IOU_SLCR_MIO_PIN_23_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Output, sdio0_bus_pow-
    # (SD card bus power) 2= test_scan, Input, test_scan_in[23]- (Test Scan Po
    # rt) = test_scan, Output, test_scan_out[23]- (Test Scan Port) 3= csu, Inp
    # ut, csu_ext_tamper- (CSU Ext Tamper)
		# PSU_IOU_SLCR_MIO_PIN_23_L2_SEL                                                  1

		# Level 3 Mux Select 0= gpio0, Input, gpio_0_pin_in[23]- (GPIO bank 0) 0=
    # gpio0, Output, gpio_0_pin_out[23]- (GPIO bank 0) 1= can0, Output, can0_p
    # hy_tx- (Can TX signal) 2= i2c0, Input, i2c0_sda_input- (SDA signal) 2= i
    # 2c0, Output, i2c0_sda_out- (SDA signal) 3= swdt0, Output, swdt0_rst_out-
    #  (Watch Dog Timer Output clock) 4= spi1, Output, spi1_mo- (MOSI signal)
    # 4= spi1, Input, spi1_si- (MOSI signal) 5= ttc0, Output, ttc0_wave_out- (
    # TTC Waveform Clock) 6= ua0, Output, ua0_txd- (UART transmitter serial ou
    # tput) 7= Not Used
		# PSU_IOU_SLCR_MIO_PIN_23_L3_SEL                                                  0

		# Configures MIO Pin 23 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF18005C, 0x000000FEU ,0x00000008U)  */
    mask_write 0XFF18005C 0x000000FE 0x00000008
		# Register : MIO_PIN_30 @ 0XFF180078</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem0, Output, gem0_rgmii_txd
    # [3]- (TX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_30_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= pcie, Input, pcie_reset_n- (
    # PCIE Reset signal)
		# PSU_IOU_SLCR_MIO_PIN_30_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= pmu, Input, pmu_gpi[4]- (PMU
    #  GPI) 2= test_scan, Input, test_scan_in[30]- (Test Scan Port) = test_sca
    # n, Output, test_scan_out[30]- (Test Scan Port) 3= dpaux, Input, dp_hot_p
    # lug_detect- (Dp Aux Hot Plug)
		# PSU_IOU_SLCR_MIO_PIN_30_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio1, Input, gpio_1_pin_in[4]- (GPIO bank 1) 0= g
    # pio1, Output, gpio_1_pin_out[4]- (GPIO bank 1) 1= can0, Input, can0_phy_
    # rx- (Can RX signal) 2= i2c0, Input, i2c0_scl_input- (SCL signal) 2= i2c0
    # , Output, i2c0_scl_out- (SCL signal) 3= swdt0, Input, swdt0_clk_in- (Wat
    # ch Dog Timer Input clock) 4= spi0, Input, spi0_mi- (MISO signal) 4= spi0
    # , Output, spi0_so- (MISO signal) 5= ttc0, Input, ttc0_clk_in- (TTC Clock
    # ) 6= ua0, Input, ua0_rxd- (UART receiver serial input) 7= trace, Output,
    #  tracedq[8]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_30_L3_SEL                                                  0

		# Configures MIO Pin 30 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180078, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF180078 0x000000FE 0x00000004
		# Register : MIO_PIN_38 @ 0XFF180098</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem1, Output, gem1_rgmii_tx_
    # clk- (TX RGMII clock)
		# PSU_IOU_SLCR_MIO_PIN_38_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_38_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Output, sdio0_clk_out-
    # (SDSDIO clock) 2= Not Used 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_38_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio1, Input, gpio_1_pin_in[12]- (GPIO bank 1) 0=
    # gpio1, Output, gpio_1_pin_out[12]- (GPIO bank 1) 1= can0, Input, can0_ph
    # y_rx- (Can RX signal) 2= i2c0, Input, i2c0_scl_input- (SCL signal) 2= i2
    # c0, Output, i2c0_scl_out- (SCL signal) 3= pjtag, Input, pjtag_tck- (PJTA
    # G TCK) 4= spi0, Input, spi0_sclk_in- (SPI Clock) 4= spi0, Output, spi0_s
    # clk_out- (SPI Clock) 5= ttc0, Input, ttc0_clk_in- (TTC Clock) 6= ua0, In
    # put, ua0_rxd- (UART receiver serial input) 7= trace, Output, trace_clk-
    # (Trace Port Clock)
		# PSU_IOU_SLCR_MIO_PIN_38_L3_SEL                                                  6

		# Configures MIO Pin 38 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180098, 0x000000FEU ,0x000000C0U)  */
    mask_write 0XFF180098 0x000000FE 0x000000C0
		# Register : MIO_PIN_39 @ 0XFF18009C</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem1, Output, gem1_rgmii_txd
    # [0]- (TX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_39_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_39_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sdio0_cd_n- (SD
    # card detect from connector) 2= sd1, Input, sd1_data_in[4]- (8-bit Data b
    # us) = sd1, Output, sdio1_data_out[4]- (8-bit Data bus) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_39_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio1, Input, gpio_1_pin_in[13]- (GPIO bank 1) 0=
    # gpio1, Output, gpio_1_pin_out[13]- (GPIO bank 1) 1= can0, Output, can0_p
    # hy_tx- (Can TX signal) 2= i2c0, Input, i2c0_sda_input- (SDA signal) 2= i
    # 2c0, Output, i2c0_sda_out- (SDA signal) 3= pjtag, Input, pjtag_tdi- (PJT
    # AG TDI) 4= spi0, Output, spi0_n_ss_out[2]- (SPI Master Selects) 5= ttc0,
    #  Output, ttc0_wave_out- (TTC Waveform Clock) 6= ua0, Output, ua0_txd- (U
    # ART transmitter serial output) 7= trace, Output, trace_ctl- (Trace Port
    # Control Signal)
		# PSU_IOU_SLCR_MIO_PIN_39_L3_SEL                                                  6

		# Configures MIO Pin 39 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF18009C, 0x000000FEU ,0x000000C0U)  */
    mask_write 0XFF18009C 0x000000FE 0x000000C0
		# Register : MIO_PIN_40 @ 0XFF1800A0</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem1, Output, gem1_rgmii_txd
    # [1]- (TX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_40_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_40_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_cmd_in- (Com
    # mand Indicator) = sd0, Output, sdio0_cmd_out- (Command Indicator) 2= sd1
    # , Input, sd1_data_in[5]- (8-bit Data bus) = sd1, Output, sdio1_data_out[
    # 5]- (8-bit Data bus) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_40_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio1, Input, gpio_1_pin_in[14]- (GPIO bank 1) 0=
    # gpio1, Output, gpio_1_pin_out[14]- (GPIO bank 1) 1= can1, Output, can1_p
    # hy_tx- (Can TX signal) 2= i2c1, Input, i2c1_scl_input- (SCL signal) 2= i
    # 2c1, Output, i2c1_scl_out- (SCL signal) 3= pjtag, Output, pjtag_tdo- (PJ
    # TAG TDO) 4= spi0, Output, spi0_n_ss_out[1]- (SPI Master Selects) 5= ttc3
    # , Input, ttc3_clk_in- (TTC Clock) 6= ua1, Output, ua1_txd- (UART transmi
    # tter serial output) 7= trace, Output, tracedq[0]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_40_L3_SEL                                                  6

		# Configures MIO Pin 40 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800A0, 0x000000FEU ,0x000000C0U)  */
    mask_write 0XFF1800A0 0x000000FE 0x000000C0
		# Register : MIO_PIN_41 @ 0XFF1800A4</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem1, Output, gem1_rgmii_txd
    # [2]- (TX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_41_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= Not Used
		# PSU_IOU_SLCR_MIO_PIN_41_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_data_in[0]-
    # (8-bit Data bus) = sd0, Output, sdio0_data_out[0]- (8-bit Data bus) 2= s
    # d1, Input, sd1_data_in[6]- (8-bit Data bus) = sd1, Output, sdio1_data_ou
    # t[6]- (8-bit Data bus) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_41_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio1, Input, gpio_1_pin_in[15]- (GPIO bank 1) 0=
    # gpio1, Output, gpio_1_pin_out[15]- (GPIO bank 1) 1= can1, Input, can1_ph
    # y_rx- (Can RX signal) 2= i2c1, Input, i2c1_sda_input- (SDA signal) 2= i2
    # c1, Output, i2c1_sda_out- (SDA signal) 3= pjtag, Input, pjtag_tms- (PJTA
    # G TMS) 4= spi0, Input, spi0_n_ss_in- (SPI Master Selects) 4= spi0, Outpu
    # t, spi0_n_ss_out[0]- (SPI Master Selects) 5= ttc3, Output, ttc3_wave_out
    # - (TTC Waveform Clock) 6= ua1, Input, ua1_rxd- (UART receiver serial inp
    # ut) 7= trace, Output, tracedq[1]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_41_L3_SEL                                                  6

		# Configures MIO Pin 41 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800A4, 0x000000FEU ,0x000000C0U)  */
    mask_write 0XFF1800A4 0x000000FE 0x000000C0
		# Register : MIO_PIN_52 @ 0XFF1800D0</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Output, gem2_rgmii_tx_
    # clk- (TX RGMII clock)
		# PSU_IOU_SLCR_MIO_PIN_52_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Input, usb0_ulpi_clk_i
    # n- (ULPI Clock)
		# PSU_IOU_SLCR_MIO_PIN_52_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_52_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[0]- (GPIO bank 2) 0= g
    # pio2, Output, gpio_2_pin_out[0]- (GPIO bank 2) 1= can1, Output, can1_phy
    # _tx- (Can TX signal) 2= i2c1, Input, i2c1_scl_input- (SCL signal) 2= i2c
    # 1, Output, i2c1_scl_out- (SCL signal) 3= pjtag, Input, pjtag_tck- (PJTAG
    #  TCK) 4= spi0, Input, spi0_sclk_in- (SPI Clock) 4= spi0, Output, spi0_sc
    # lk_out- (SPI Clock) 5= ttc1, Input, ttc1_clk_in- (TTC Clock) 6= ua1, Out
    # put, ua1_txd- (UART transmitter serial output) 7= trace, Output, trace_c
    # lk- (Trace Port Clock)
		# PSU_IOU_SLCR_MIO_PIN_52_L3_SEL                                                  0

		# Configures MIO Pin 52 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800D0, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800D0 0x000000FE 0x00000004
		# Register : MIO_PIN_53 @ 0XFF1800D4</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Output, gem2_rgmii_txd
    # [0]- (TX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_53_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Input, usb0_ulpi_dir-
    # (Data bus direction control)
		# PSU_IOU_SLCR_MIO_PIN_53_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_53_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[1]- (GPIO bank 2) 0= g
    # pio2, Output, gpio_2_pin_out[1]- (GPIO bank 2) 1= can1, Input, can1_phy_
    # rx- (Can RX signal) 2= i2c1, Input, i2c1_sda_input- (SDA signal) 2= i2c1
    # , Output, i2c1_sda_out- (SDA signal) 3= pjtag, Input, pjtag_tdi- (PJTAG
    # TDI) 4= spi0, Output, spi0_n_ss_out[2]- (SPI Master Selects) 5= ttc1, Ou
    # tput, ttc1_wave_out- (TTC Waveform Clock) 6= ua1, Input, ua1_rxd- (UART
    # receiver serial input) 7= trace, Output, trace_ctl- (Trace Port Control
    # Signal)
		# PSU_IOU_SLCR_MIO_PIN_53_L3_SEL                                                  0

		# Configures MIO Pin 53 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800D4, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800D4 0x000000FE 0x00000004
		# Register : MIO_PIN_54 @ 0XFF1800D8</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Output, gem2_rgmii_txd
    # [1]- (TX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_54_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Input, usb0_ulpi_rx_da
    # ta[2]- (ULPI data bus) 1= usb0, Output, usb0_ulpi_tx_data[2]- (ULPI data
    #  bus)
		# PSU_IOU_SLCR_MIO_PIN_54_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_54_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[2]- (GPIO bank 2) 0= g
    # pio2, Output, gpio_2_pin_out[2]- (GPIO bank 2) 1= can0, Input, can0_phy_
    # rx- (Can RX signal) 2= i2c0, Input, i2c0_scl_input- (SCL signal) 2= i2c0
    # , Output, i2c0_scl_out- (SCL signal) 3= pjtag, Output, pjtag_tdo- (PJTAG
    #  TDO) 4= spi0, Output, spi0_n_ss_out[1]- (SPI Master Selects) 5= ttc0, I
    # nput, ttc0_clk_in- (TTC Clock) 6= ua0, Input, ua0_rxd- (UART receiver se
    # rial input) 7= trace, Output, tracedq[0]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_54_L3_SEL                                                  0

		# Configures MIO Pin 54 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800D8, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800D8 0x000000FE 0x00000004
		# Register : MIO_PIN_55 @ 0XFF1800DC</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Output, gem2_rgmii_txd
    # [2]- (TX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_55_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Input, usb0_ulpi_nxt-
    # (Data flow control signal from the PHY)
		# PSU_IOU_SLCR_MIO_PIN_55_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_55_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[3]- (GPIO bank 2) 0= g
    # pio2, Output, gpio_2_pin_out[3]- (GPIO bank 2) 1= can0, Output, can0_phy
    # _tx- (Can TX signal) 2= i2c0, Input, i2c0_sda_input- (SDA signal) 2= i2c
    # 0, Output, i2c0_sda_out- (SDA signal) 3= pjtag, Input, pjtag_tms- (PJTAG
    #  TMS) 4= spi0, Input, spi0_n_ss_in- (SPI Master Selects) 4= spi0, Output
    # , spi0_n_ss_out[0]- (SPI Master Selects) 5= ttc0, Output, ttc0_wave_out-
    #  (TTC Waveform Clock) 6= ua0, Output, ua0_txd- (UART transmitter serial
    # output) 7= trace, Output, tracedq[1]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_55_L3_SEL                                                  0

		# Configures MIO Pin 55 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800DC, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800DC 0x000000FE 0x00000004
		# Register : MIO_PIN_56 @ 0XFF1800E0</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Output, gem2_rgmii_txd
    # [3]- (TX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_56_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Input, usb0_ulpi_rx_da
    # ta[0]- (ULPI data bus) 1= usb0, Output, usb0_ulpi_tx_data[0]- (ULPI data
    #  bus)
		# PSU_IOU_SLCR_MIO_PIN_56_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_56_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[4]- (GPIO bank 2) 0= g
    # pio2, Output, gpio_2_pin_out[4]- (GPIO bank 2) 1= can1, Output, can1_phy
    # _tx- (Can TX signal) 2= i2c1, Input, i2c1_scl_input- (SCL signal) 2= i2c
    # 1, Output, i2c1_scl_out- (SCL signal) 3= swdt1, Input, swdt1_clk_in- (Wa
    # tch Dog Timer Input clock) 4= spi0, Input, spi0_mi- (MISO signal) 4= spi
    # 0, Output, spi0_so- (MISO signal) 5= ttc3, Input, ttc3_clk_in- (TTC Cloc
    # k) 6= ua1, Output, ua1_txd- (UART transmitter serial output) 7= trace, O
    # utput, tracedq[2]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_56_L3_SEL                                                  0

		# Configures MIO Pin 56 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800E0, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800E0 0x000000FE 0x00000004
		# Register : MIO_PIN_57 @ 0XFF1800E4</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Output, gem2_rgmii_tx_
    # ctl- (TX RGMII control)
		# PSU_IOU_SLCR_MIO_PIN_57_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Input, usb0_ulpi_rx_da
    # ta[1]- (ULPI data bus) 1= usb0, Output, usb0_ulpi_tx_data[1]- (ULPI data
    #  bus)
		# PSU_IOU_SLCR_MIO_PIN_57_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_57_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[5]- (GPIO bank 2) 0= g
    # pio2, Output, gpio_2_pin_out[5]- (GPIO bank 2) 1= can1, Input, can1_phy_
    # rx- (Can RX signal) 2= i2c1, Input, i2c1_sda_input- (SDA signal) 2= i2c1
    # , Output, i2c1_sda_out- (SDA signal) 3= swdt1, Output, swdt1_rst_out- (W
    # atch Dog Timer Output clock) 4= spi0, Output, spi0_mo- (MOSI signal) 4=
    # spi0, Input, spi0_si- (MOSI signal) 5= ttc3, Output, ttc3_wave_out- (TTC
    #  Waveform Clock) 6= ua1, Input, ua1_rxd- (UART receiver serial input) 7=
    #  trace, Output, tracedq[3]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_57_L3_SEL                                                  0

		# Configures MIO Pin 57 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800E4, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800E4 0x000000FE 0x00000004
		# Register : MIO_PIN_58 @ 0XFF1800E8</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Input, gem2_rgmii_rx_c
    # lk- (RX RGMII clock)
		# PSU_IOU_SLCR_MIO_PIN_58_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Output, usb0_ulpi_stp-
    #  (Asserted to end or interrupt transfers)
		# PSU_IOU_SLCR_MIO_PIN_58_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_58_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[6]- (GPIO bank 2) 0= g
    # pio2, Output, gpio_2_pin_out[6]- (GPIO bank 2) 1= can0, Input, can0_phy_
    # rx- (Can RX signal) 2= i2c0, Input, i2c0_scl_input- (SCL signal) 2= i2c0
    # , Output, i2c0_scl_out- (SCL signal) 3= pjtag, Input, pjtag_tck- (PJTAG
    # TCK) 4= spi1, Input, spi1_sclk_in- (SPI Clock) 4= spi1, Output, spi1_scl
    # k_out- (SPI Clock) 5= ttc2, Input, ttc2_clk_in- (TTC Clock) 6= ua0, Inpu
    # t, ua0_rxd- (UART receiver serial input) 7= trace, Output, tracedq[4]- (
    # Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_58_L3_SEL                                                  0

		# Configures MIO Pin 58 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800E8, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800E8 0x000000FE 0x00000004
		# Register : MIO_PIN_59 @ 0XFF1800EC</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Input, gem2_rgmii_rxd[
    # 0]- (RX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_59_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Input, usb0_ulpi_rx_da
    # ta[3]- (ULPI data bus) 1= usb0, Output, usb0_ulpi_tx_data[3]- (ULPI data
    #  bus)
		# PSU_IOU_SLCR_MIO_PIN_59_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_59_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[7]- (GPIO bank 2) 0= g
    # pio2, Output, gpio_2_pin_out[7]- (GPIO bank 2) 1= can0, Output, can0_phy
    # _tx- (Can TX signal) 2= i2c0, Input, i2c0_sda_input- (SDA signal) 2= i2c
    # 0, Output, i2c0_sda_out- (SDA signal) 3= pjtag, Input, pjtag_tdi- (PJTAG
    #  TDI) 4= spi1, Output, spi1_n_ss_out[2]- (SPI Master Selects) 5= ttc2, O
    # utput, ttc2_wave_out- (TTC Waveform Clock) 6= ua0, Output, ua0_txd- (UAR
    # T transmitter serial output) 7= trace, Output, tracedq[5]- (Trace Port D
    # atabus)
		# PSU_IOU_SLCR_MIO_PIN_59_L3_SEL                                                  0

		# Configures MIO Pin 59 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800EC, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800EC 0x000000FE 0x00000004
		# Register : MIO_PIN_60 @ 0XFF1800F0</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Input, gem2_rgmii_rxd[
    # 1]- (RX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_60_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Input, usb0_ulpi_rx_da
    # ta[4]- (ULPI data bus) 1= usb0, Output, usb0_ulpi_tx_data[4]- (ULPI data
    #  bus)
		# PSU_IOU_SLCR_MIO_PIN_60_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_60_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[8]- (GPIO bank 2) 0= g
    # pio2, Output, gpio_2_pin_out[8]- (GPIO bank 2) 1= can1, Output, can1_phy
    # _tx- (Can TX signal) 2= i2c1, Input, i2c1_scl_input- (SCL signal) 2= i2c
    # 1, Output, i2c1_scl_out- (SCL signal) 3= pjtag, Output, pjtag_tdo- (PJTA
    # G TDO) 4= spi1, Output, spi1_n_ss_out[1]- (SPI Master Selects) 5= ttc1,
    # Input, ttc1_clk_in- (TTC Clock) 6= ua1, Output, ua1_txd- (UART transmitt
    # er serial output) 7= trace, Output, tracedq[6]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_60_L3_SEL                                                  0

		# Configures MIO Pin 60 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800F0, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800F0 0x000000FE 0x00000004
		# Register : MIO_PIN_61 @ 0XFF1800F4</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Input, gem2_rgmii_rxd[
    # 2]- (RX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_61_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Input, usb0_ulpi_rx_da
    # ta[5]- (ULPI data bus) 1= usb0, Output, usb0_ulpi_tx_data[5]- (ULPI data
    #  bus)
		# PSU_IOU_SLCR_MIO_PIN_61_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_61_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[9]- (GPIO bank 2) 0= g
    # pio2, Output, gpio_2_pin_out[9]- (GPIO bank 2) 1= can1, Input, can1_phy_
    # rx- (Can RX signal) 2= i2c1, Input, i2c1_sda_input- (SDA signal) 2= i2c1
    # , Output, i2c1_sda_out- (SDA signal) 3= pjtag, Input, pjtag_tms- (PJTAG
    # TMS) 4= spi1, Input, spi1_n_ss_in- (SPI Master Selects) 4= spi1, Output,
    #  spi1_n_ss_out[0]- (SPI Master Selects) 5= ttc1, Output, ttc1_wave_out-
    # (TTC Waveform Clock) 6= ua1, Input, ua1_rxd- (UART receiver serial input
    # ) 7= trace, Output, tracedq[7]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_61_L3_SEL                                                  0

		# Configures MIO Pin 61 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800F4, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800F4 0x000000FE 0x00000004
		# Register : MIO_PIN_62 @ 0XFF1800F8</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Input, gem2_rgmii_rxd[
    # 3]- (RX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_62_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Input, usb0_ulpi_rx_da
    # ta[6]- (ULPI data bus) 1= usb0, Output, usb0_ulpi_tx_data[6]- (ULPI data
    #  bus)
		# PSU_IOU_SLCR_MIO_PIN_62_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_62_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[10]- (GPIO bank 2) 0=
    # gpio2, Output, gpio_2_pin_out[10]- (GPIO bank 2) 1= can0, Input, can0_ph
    # y_rx- (Can RX signal) 2= i2c0, Input, i2c0_scl_input- (SCL signal) 2= i2
    # c0, Output, i2c0_scl_out- (SCL signal) 3= swdt0, Input, swdt0_clk_in- (W
    # atch Dog Timer Input clock) 4= spi1, Input, spi1_mi- (MISO signal) 4= sp
    # i1, Output, spi1_so- (MISO signal) 5= ttc0, Input, ttc0_clk_in- (TTC Clo
    # ck) 6= ua0, Input, ua0_rxd- (UART receiver serial input) 7= trace, Outpu
    # t, tracedq[8]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_62_L3_SEL                                                  0

		# Configures MIO Pin 62 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800F8, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800F8 0x000000FE 0x00000004
		# Register : MIO_PIN_63 @ 0XFF1800FC</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem2, Input, gem2_rgmii_rx_c
    # tl- (RX RGMII control )
		# PSU_IOU_SLCR_MIO_PIN_63_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb0, Input, usb0_ulpi_rx_da
    # ta[7]- (ULPI data bus) 1= usb0, Output, usb0_ulpi_tx_data[7]- (ULPI data
    #  bus)
		# PSU_IOU_SLCR_MIO_PIN_63_L1_SEL                                                  1

		# Level 2 Mux Select 0= Level 3 Mux Output 1= Not Used 2= Not Used 3= Not
    # Used
		# PSU_IOU_SLCR_MIO_PIN_63_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[11]- (GPIO bank 2) 0=
    # gpio2, Output, gpio_2_pin_out[11]- (GPIO bank 2) 1= can0, Output, can0_p
    # hy_tx- (Can TX signal) 2= i2c0, Input, i2c0_sda_input- (SDA signal) 2= i
    # 2c0, Output, i2c0_sda_out- (SDA signal) 3= swdt0, Output, swdt0_rst_out-
    #  (Watch Dog Timer Output clock) 4= spi1, Output, spi1_mo- (MOSI signal)
    # 4= spi1, Input, spi1_si- (MOSI signal) 5= ttc0, Output, ttc0_wave_out- (
    # TTC Waveform Clock) 6= ua0, Output, ua0_txd- (UART transmitter serial ou
    # tput) 7= trace, Output, tracedq[9]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_63_L3_SEL                                                  0

		# Configures MIO Pin 63 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF1800FC, 0x000000FEU ,0x00000004U)  */
    mask_write 0XFF1800FC 0x000000FE 0x00000004
		# Register : MIO_PIN_64 @ 0XFF180100</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem3, Output, gem3_rgmii_tx_
    # clk- (TX RGMII clock)
		# PSU_IOU_SLCR_MIO_PIN_64_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb1, Input, usb1_ulpi_clk_i
    # n- (ULPI Clock)
		# PSU_IOU_SLCR_MIO_PIN_64_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Output, sdio0_clk_out-
    # (SDSDIO clock) 2= Not Used 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_64_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[12]- (GPIO bank 2) 0=
    # gpio2, Output, gpio_2_pin_out[12]- (GPIO bank 2) 1= can1, Output, can1_p
    # hy_tx- (Can TX signal) 2= i2c1, Input, i2c1_scl_input- (SCL signal) 2= i
    # 2c1, Output, i2c1_scl_out- (SCL signal) 3= swdt1, Input, swdt1_clk_in- (
    # Watch Dog Timer Input clock) 4= spi0, Input, spi0_sclk_in- (SPI Clock) 4
    # = spi0, Output, spi0_sclk_out- (SPI Clock) 5= ttc3, Input, ttc3_clk_in-
    # (TTC Clock) 6= ua1, Output, ua1_txd- (UART transmitter serial output) 7=
    #  trace, Output, tracedq[10]- (Trace Port Databus)
		# PSU_IOU_SLCR_MIO_PIN_64_L3_SEL                                                  0

		# Configures MIO Pin 64 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180100, 0x000000FEU ,0x00000000U)  */
    mask_write 0XFF180100 0x000000FE 0x00000000
		# Register : MIO_PIN_70 @ 0XFF180118</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem3, Input, gem3_rgmii_rx_c
    # lk- (RX RGMII clock)
		# PSU_IOU_SLCR_MIO_PIN_70_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb1, Output, usb1_ulpi_stp-
    #  (Asserted to end or interrupt transfers)
		# PSU_IOU_SLCR_MIO_PIN_70_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_data_in[3]-
    # (8-bit Data bus) = sd0, Output, sdio0_data_out[3]- (8-bit Data bus) 2= s
    # d1, Output, sdio1_bus_pow- (SD card bus power) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_70_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[18]- (GPIO bank 2) 0=
    # gpio2, Output, gpio_2_pin_out[18]- (GPIO bank 2) 1= can0, Input, can0_ph
    # y_rx- (Can RX signal) 2= i2c0, Input, i2c0_scl_input- (SCL signal) 2= i2
    # c0, Output, i2c0_scl_out- (SCL signal) 3= swdt0, Input, swdt0_clk_in- (W
    # atch Dog Timer Input clock) 4= spi1, Input, spi1_sclk_in- (SPI Clock) 4=
    #  spi1, Output, spi1_sclk_out- (SPI Clock) 5= ttc0, Input, ttc0_clk_in- (
    # TTC Clock) 6= ua0, Input, ua0_rxd- (UART receiver serial input) 7= Not U
    # sed
		# PSU_IOU_SLCR_MIO_PIN_70_L3_SEL                                                  2

		# Configures MIO Pin 70 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF180118, 0x000000FEU ,0x00000040U)  */
    mask_write 0XFF180118 0x000000FE 0x00000040
		# Register : MIO_PIN_71 @ 0XFF18011C</p>

		# Level 0 Mux Select 0= Level 1 Mux Output 1= gem3, Input, gem3_rgmii_rxd[
    # 0]- (RX RGMII data)
		# PSU_IOU_SLCR_MIO_PIN_71_L0_SEL                                                  0

		# Level 1 Mux Select 0= Level 2 Mux Output 1= usb1, Input, usb1_ulpi_rx_da
    # ta[3]- (ULPI data bus) 1= usb1, Output, usb1_ulpi_tx_data[3]- (ULPI data
    #  bus)
		# PSU_IOU_SLCR_MIO_PIN_71_L1_SEL                                                  0

		# Level 2 Mux Select 0= Level 3 Mux Output 1= sd0, Input, sd0_data_in[4]-
    # (8-bit Data bus) = sd0, Output, sdio0_data_out[4]- (8-bit Data bus) 2= s
    # d1, Input, sd1_data_in[0]- (8-bit Data bus) = sd1, Output, sdio1_data_ou
    # t[0]- (8-bit Data bus) 3= Not Used
		# PSU_IOU_SLCR_MIO_PIN_71_L2_SEL                                                  0

		# Level 3 Mux Select 0= gpio2, Input, gpio_2_pin_in[19]- (GPIO bank 2) 0=
    # gpio2, Output, gpio_2_pin_out[19]- (GPIO bank 2) 1= can0, Output, can0_p
    # hy_tx- (Can TX signal) 2= i2c0, Input, i2c0_sda_input- (SDA signal) 2= i
    # 2c0, Output, i2c0_sda_out- (SDA signal) 3= swdt0, Output, swdt0_rst_out-
    #  (Watch Dog Timer Output clock) 4= spi1, Output, spi1_n_ss_out[2]- (SPI
    # Master Selects) 5= ttc0, Output, ttc0_wave_out- (TTC Waveform Clock) 6=
    # ua0, Output, ua0_txd- (UART transmitter serial output) 7= Not Used
		# PSU_IOU_SLCR_MIO_PIN_71_L3_SEL                                                  2

		# Configures MIO Pin 71 peripheral interface mapping
		#(OFFSET, MASK, VALUE)      (0XFF18011C, 0x000000FEU ,0x00000040U)  */
    mask_write 0XFF18011C 0x000000FE 0x00000040
		# Register : MIO_MST_TRI0 @ 0XFF180204</p>

		# Master Tri-state Enable for pin 0, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_00_TRI                                            0

		# Master Tri-state Enable for pin 1, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_01_TRI                                            0

		# Master Tri-state Enable for pin 2, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_02_TRI                                            0

		# Master Tri-state Enable for pin 3, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_03_TRI                                            0

		# Master Tri-state Enable for pin 4, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_04_TRI                                            0

		# Master Tri-state Enable for pin 5, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_05_TRI                                            0

		# Master Tri-state Enable for pin 6, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_06_TRI                                            0

		# Master Tri-state Enable for pin 7, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_07_TRI                                            0

		# Master Tri-state Enable for pin 13, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_13_TRI                                            0

		# Master Tri-state Enable for pin 14, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_14_TRI                                            0

		# Master Tri-state Enable for pin 15, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_15_TRI                                            0

		# Master Tri-state Enable for pin 16, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_16_TRI                                            0

		# Master Tri-state Enable for pin 17, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_17_TRI                                            0

		# Master Tri-state Enable for pin 18, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_18_TRI                                            0

		# Master Tri-state Enable for pin 19, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_19_TRI                                            0

		# Master Tri-state Enable for pin 20, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_20_TRI                                            0

		# Master Tri-state Enable for pin 21, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_21_TRI                                            0

		# Master Tri-state Enable for pin 22, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_22_TRI                                            0

		# Master Tri-state Enable for pin 23, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_23_TRI                                            0

		# Master Tri-state Enable for pin 30, active high
		# PSU_IOU_SLCR_MIO_MST_TRI0_PIN_30_TRI                                            1

		# MIO pin Tri-state Enables, 31:0
		#(OFFSET, MASK, VALUE)      (0XFF180204, 0x40FFE0FFU ,0x40000000U)  */
    mask_write 0XFF180204 0x40FFE0FF 0x40000000
		# Register : MIO_MST_TRI1 @ 0XFF180208</p>

		# Master Tri-state Enable for pin 38, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_38_TRI                                            1

		# Master Tri-state Enable for pin 39, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_39_TRI                                            0

		# Master Tri-state Enable for pin 40, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_40_TRI                                            0

		# Master Tri-state Enable for pin 41, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_41_TRI                                            1

		# Master Tri-state Enable for pin 52, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_52_TRI                                            1

		# Master Tri-state Enable for pin 53, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_53_TRI                                            1

		# Master Tri-state Enable for pin 54, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_54_TRI                                            0

		# Master Tri-state Enable for pin 55, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_55_TRI                                            1

		# Master Tri-state Enable for pin 56, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_56_TRI                                            0

		# Master Tri-state Enable for pin 57, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_57_TRI                                            0

		# Master Tri-state Enable for pin 58, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_58_TRI                                            0

		# Master Tri-state Enable for pin 59, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_59_TRI                                            0

		# Master Tri-state Enable for pin 60, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_60_TRI                                            0

		# Master Tri-state Enable for pin 61, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_61_TRI                                            0

		# Master Tri-state Enable for pin 62, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_62_TRI                                            0

		# Master Tri-state Enable for pin 63, active high
		# PSU_IOU_SLCR_MIO_MST_TRI1_PIN_63_TRI                                            0

		# MIO pin Tri-state Enables, 63:32
		#(OFFSET, MASK, VALUE)      (0XFF180208, 0xFFF003C0U ,0x00B00240U)  */
    mask_write 0XFF180208 0xFFF003C0 0x00B00240
		# Register : MIO_MST_TRI2 @ 0XFF18020C</p>

		# Master Tri-state Enable for pin 64, active high
		# PSU_IOU_SLCR_MIO_MST_TRI2_PIN_64_TRI                                            0

		# Master Tri-state Enable for pin 70, active high
		# PSU_IOU_SLCR_MIO_MST_TRI2_PIN_70_TRI                                            0

		# Master Tri-state Enable for pin 71, active high
		# PSU_IOU_SLCR_MIO_MST_TRI2_PIN_71_TRI                                            0

		# MIO pin Tri-state Enables, 77:64
		#(OFFSET, MASK, VALUE)      (0XFF18020C, 0x000000C1U ,0x00000000U)  */
    mask_write 0XFF18020C 0x000000C1 0x00000000
		# Register : bank0_ctrl0 @ 0XFF180138</p>

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_0                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_1                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_2                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_3                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_4                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_5                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_6                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_7                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_8                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_9                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_10                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_11                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_12                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_13                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_14                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_15                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_16                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_17                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_18                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_19                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_20                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_21                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_22                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_23                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_24                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL0_DRIVE0_BIT_25                                          1

		# Drive0 control to MIO Bank 0 - control MIO[25:0]
		#(OFFSET, MASK, VALUE)      (0XFF180138, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF180138 0x03FFFFFF 0x03FFFFFF
		# Register : bank0_ctrl1 @ 0XFF18013C</p>

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_0                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_1                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_2                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_3                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_4                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_5                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_6                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_7                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_8                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_9                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_10                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_11                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_12                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_13                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_14                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_15                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_16                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_17                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_18                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_19                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_20                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_21                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_22                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_23                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_24                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL1_DRIVE1_BIT_25                                          1

		# Drive1 control to MIO Bank 0 - control MIO[25:0]
		#(OFFSET, MASK, VALUE)      (0XFF18013C, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF18013C 0x03FFFFFF 0x03FFFFFF
		# Register : bank0_ctrl3 @ 0XFF180140</p>

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_0                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_1                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_2                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_3                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_4                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_5                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_6                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_7                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_8                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_9                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_10                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_11                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_12                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_13                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_14                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_15                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_16                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_17                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_18                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_19                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_20                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_21                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_22                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_23                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_24                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL3_SCHMITT_CMOS_N_BIT_25                                  0

		# Selects either Schmitt or CMOS input for MIO Bank 0 - control MIO[25:0]
		#(OFFSET, MASK, VALUE)      (0XFF180140, 0x03FFFFFFU ,0x00000000U)  */
    mask_write 0XFF180140 0x03FFFFFF 0x00000000
		# Register : bank0_ctrl4 @ 0XFF180144</p>

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_0                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_1                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_2                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_3                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_4                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_5                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_6                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_7                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_8                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_9                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_10                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_11                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_12                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_13                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_14                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_15                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_16                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_17                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_18                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_19                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_20                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_21                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_22                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_23                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_24                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL4_PULL_HIGH_LOW_N_BIT_25                                 1

		# When mio_bank0_pull_enable is set, this selects pull up or pull down for
    #  MIO Bank 0 - control MIO[25:0]
		#(OFFSET, MASK, VALUE)      (0XFF180144, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF180144 0x03FFFFFF 0x03FFFFFF
		# Register : bank0_ctrl5 @ 0XFF180148</p>

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_0                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_1                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_2                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_3                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_4                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_5                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_6                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_7                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_8                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_9                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_10                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_11                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_12                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_13                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_14                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_15                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_16                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_17                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_18                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_19                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_20                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_21                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_22                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_23                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_24                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL5_PULL_ENABLE_BIT_25                                     1

		# When set, this enables mio_bank0_pullupdown to selects pull up or pull d
    # own for MIO Bank 0 - control MIO[25:0]
		#(OFFSET, MASK, VALUE)      (0XFF180148, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF180148 0x03FFFFFF 0x03FFFFFF
		# Register : bank0_ctrl6 @ 0XFF18014C</p>

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_0                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_1                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_2                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_3                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_4                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_5                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_6                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_7                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_8                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_9                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_10                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_11                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_12                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_13                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_14                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_15                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_16                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_17                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_18                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_19                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_20                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_21                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_22                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_23                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_24                                0

		# Each bit applies to a single IO. Bit 0 for MIO[0].
		# PSU_IOU_SLCR_BANK0_CTRL6_SLOW_FAST_SLEW_N_BIT_25                                0

		# Slew rate control to MIO Bank 0 - control MIO[25:0]
		#(OFFSET, MASK, VALUE)      (0XFF18014C, 0x03FFFFFFU ,0x00000000U)  */
    mask_write 0XFF18014C 0x03FFFFFF 0x00000000
		# Register : bank1_ctrl0 @ 0XFF180154</p>

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_0                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_1                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_2                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_3                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_4                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_5                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_6                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_7                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_8                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_9                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_10                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_11                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_12                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_13                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_14                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_15                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_16                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_17                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_18                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_19                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_20                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_21                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_22                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_23                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_24                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL0_DRIVE0_BIT_25                                          1

		# Drive0 control to MIO Bank 1 - control MIO[51:26]
		#(OFFSET, MASK, VALUE)      (0XFF180154, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF180154 0x03FFFFFF 0x03FFFFFF
		# Register : bank1_ctrl1 @ 0XFF180158</p>

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_0                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_1                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_2                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_3                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_4                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_5                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_6                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_7                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_8                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_9                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_10                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_11                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_12                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_13                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_14                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_15                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_16                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_17                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_18                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_19                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_20                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_21                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_22                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_23                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_24                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL1_DRIVE1_BIT_25                                          1

		# Drive1 control to MIO Bank 1 - control MIO[51:26]
		#(OFFSET, MASK, VALUE)      (0XFF180158, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF180158 0x03FFFFFF 0x03FFFFFF
		# Register : bank1_ctrl3 @ 0XFF18015C</p>

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_0                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_1                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_2                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_3                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_4                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_5                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_6                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_7                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_8                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_9                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_10                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_11                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_12                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_13                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_14                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_15                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_16                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_17                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_18                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_19                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_20                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_21                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_22                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_23                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_24                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL3_SCHMITT_CMOS_N_BIT_25                                  0

		# Selects either Schmitt or CMOS input for MIO Bank 1 - control MIO[51:26]
		#(OFFSET, MASK, VALUE)      (0XFF18015C, 0x03FFFFFFU ,0x00000000U)  */
    mask_write 0XFF18015C 0x03FFFFFF 0x00000000
		# Register : bank1_ctrl4 @ 0XFF180160</p>

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_0                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_1                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_2                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_3                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_4                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_5                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_6                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_7                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_8                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_9                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_10                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_11                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_12                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_13                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_14                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_15                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_16                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_17                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_18                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_19                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_20                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_21                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_22                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_23                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_24                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL4_PULL_HIGH_LOW_N_BIT_25                                 1

		# When mio_bank1_pull_enable is set, this selects pull up or pull down for
    #  MIO Bank 1 - control MIO[51:26]
		#(OFFSET, MASK, VALUE)      (0XFF180160, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF180160 0x03FFFFFF 0x03FFFFFF
		# Register : bank1_ctrl5 @ 0XFF180164</p>

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_0                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_1                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_2                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_3                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_4                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_5                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_6                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_7                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_8                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_9                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_10                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_11                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_12                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_13                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_14                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_15                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_16                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_17                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_18                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_19                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_20                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_21                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_22                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_23                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_24                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_25                                     1

		# When set, this enables mio_bank1_pullupdown to selects pull up or pull d
    # own for MIO Bank 1 - control MIO[51:26]
		#(OFFSET, MASK, VALUE)      (0XFF180164, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF180164 0x03FFFFFF 0x03FFFFFF
		# Register : bank1_ctrl6 @ 0XFF180168</p>

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_0                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_1                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_2                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_3                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_4                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_5                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_6                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_7                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_8                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_9                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_10                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_11                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_12                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_13                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_14                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_15                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_16                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_17                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_18                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_19                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_20                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_21                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_22                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_23                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_24                                0

		# Each bit applies to a single IO. Bit 0 for MIO[26].
		# PSU_IOU_SLCR_BANK1_CTRL6_SLOW_FAST_SLEW_N_BIT_25                                0

		# Slew rate control to MIO Bank 1 - control MIO[51:26]
		#(OFFSET, MASK, VALUE)      (0XFF180168, 0x03FFFFFFU ,0x00000000U)  */
    mask_write 0XFF180168 0x03FFFFFF 0x00000000
		# Register : bank2_ctrl0 @ 0XFF180170</p>

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_0                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_1                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_2                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_3                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_4                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_5                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_6                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_7                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_8                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_9                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_10                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_11                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_12                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_13                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_14                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_15                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_16                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_17                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_18                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_19                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_20                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_21                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_22                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_23                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_24                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL0_DRIVE0_BIT_25                                          1

		# Drive0 control to MIO Bank 2 - control MIO[77:52]
		#(OFFSET, MASK, VALUE)      (0XFF180170, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF180170 0x03FFFFFF 0x03FFFFFF
		# Register : bank2_ctrl1 @ 0XFF180174</p>

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_0                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_1                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_2                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_3                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_4                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_5                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_6                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_7                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_8                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_9                                           1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_10                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_11                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_12                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_13                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_14                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_15                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_16                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_17                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_18                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_19                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_20                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_21                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_22                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_23                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_24                                          1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL1_DRIVE1_BIT_25                                          1

		# Drive1 control to MIO Bank 2 - control MIO[77:52]
		#(OFFSET, MASK, VALUE)      (0XFF180174, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF180174 0x03FFFFFF 0x03FFFFFF
		# Register : bank2_ctrl3 @ 0XFF180178</p>

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_0                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_1                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_2                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_3                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_4                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_5                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_6                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_7                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_8                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_9                                   0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_10                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_11                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_12                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_13                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_14                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_15                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_16                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_17                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_18                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_19                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_20                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_21                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_22                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_23                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_24                                  0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL3_SCHMITT_CMOS_N_BIT_25                                  0

		# Selects either Schmitt or CMOS input for MIO Bank 2 - control MIO[77:52]
		#(OFFSET, MASK, VALUE)      (0XFF180178, 0x03FFFFFFU ,0x00000000U)  */
    mask_write 0XFF180178 0x03FFFFFF 0x00000000
		# Register : bank2_ctrl4 @ 0XFF18017C</p>

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_0                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_1                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_2                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_3                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_4                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_5                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_6                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_7                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_8                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_9                                  1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_10                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_11                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_12                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_13                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_14                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_15                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_16                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_17                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_18                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_19                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_20                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_21                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_22                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_23                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_24                                 1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL4_PULL_HIGH_LOW_N_BIT_25                                 1

		# When mio_bank2_pull_enable is set, this selects pull up or pull down for
    #  MIO Bank 2 - control MIO[77:52]
		#(OFFSET, MASK, VALUE)      (0XFF18017C, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF18017C 0x03FFFFFF 0x03FFFFFF
		# Register : bank2_ctrl5 @ 0XFF180180</p>

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_0                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_1                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_2                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_3                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_4                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_5                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_6                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_7                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_8                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_9                                      1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_10                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_11                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_12                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_13                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_14                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_15                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_16                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_17                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_18                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_19                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_20                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_21                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_22                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_23                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_24                                     1

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL5_PULL_ENABLE_BIT_25                                     1

		# When set, this enables mio_bank2_pullupdown to selects pull up or pull d
    # own for MIO Bank 2 - control MIO[77:52]
		#(OFFSET, MASK, VALUE)      (0XFF180180, 0x03FFFFFFU ,0x03FFFFFFU)  */
    mask_write 0XFF180180 0x03FFFFFF 0x03FFFFFF
		# Register : bank2_ctrl6 @ 0XFF180184</p>

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_0                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_1                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_2                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_3                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_4                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_5                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_6                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_7                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_8                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_9                                 0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_10                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_11                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_12                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_13                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_14                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_15                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_16                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_17                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_18                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_19                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_20                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_21                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_22                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_23                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_24                                0

		# Each bit applies to a single IO. Bit 0 for MIO[52].
		# PSU_IOU_SLCR_BANK2_CTRL6_SLOW_FAST_SLEW_N_BIT_25                                0

		# Slew rate control to MIO Bank 2 - control MIO[77:52]
		#(OFFSET, MASK, VALUE)      (0XFF180184, 0x03FFFFFFU ,0x00000000U)  */
    mask_write 0XFF180184 0x03FFFFFF 0x00000000
		# : LOOPBACK
		# Register : MIO_LOOPBACK @ 0XFF180200</p>

		# I2C Loopback Control. 0 = Connect I2C inputs according to MIO mapping. 1
    #  = Loop I2C 0 outputs to I2C 1 inputs, and I2C 1 outputs to I2C 0 inputs
    # .
		# PSU_IOU_SLCR_MIO_LOOPBACK_I2C0_LOOP_I2C1                                        0

		# CAN Loopback Control. 0 = Connect CAN inputs according to MIO mapping. 1
    #  = Loop CAN 0 Tx to CAN 1 Rx, and CAN 1 Tx to CAN 0 Rx.
		# PSU_IOU_SLCR_MIO_LOOPBACK_CAN0_LOOP_CAN1                                        0

		# UART Loopback Control. 0 = Connect UART inputs according to MIO mapping.
    #  1 = Loop UART 0 outputs to UART 1 inputs, and UART 1 outputs to UART 0
    # inputs. RXD/TXD cross-connected. RTS/CTS cross-connected. DSR, DTR, DCD
    # and RI not used.
		# PSU_IOU_SLCR_MIO_LOOPBACK_UA0_LOOP_UA1                                          0

		# SPI Loopback Control. 0 = Connect SPI inputs according to MIO mapping. 1
    #  = Loop SPI 0 outputs to SPI 1 inputs, and SPI 1 outputs to SPI 0 inputs
    # . The other SPI core will appear on the LS Slave Select.
		# PSU_IOU_SLCR_MIO_LOOPBACK_SPI0_LOOP_SPI1                                        0

		# Loopback function within MIO
		#(OFFSET, MASK, VALUE)      (0XFF180200, 0x0000000FU ,0x00000000U)  */
    mask_write 0XFF180200 0x0000000F 0x00000000
}

set psu_peripherals_pre_init_data {
		# : SYSMON CLOCK PRESET TO IOPLL AT 1500 MHZ FROM PBR TO MAKE AMS CLOCK UNDER RANGE
		# Register : AMS_REF_CTRL @ 0XFF5E0108</p>

		# 6 bit divider
		# PSU_CRL_APB_AMS_REF_CTRL_DIVISOR1                                               1

		# 6 bit divider
		# PSU_CRL_APB_AMS_REF_CTRL_DIVISOR0                                               35

		# 000 = RPLL; 010 = IOPLL; 011 = DPLL; (This signal may only be toggled af
    # ter 4 cycles of the old clock and 4 cycles of the new clock. This is not
    #  usually an issue, but designers must be aware.)
		# PSU_CRL_APB_AMS_REF_CTRL_SRCSEL                                                 2

		# Clock active signal. Switch to 0 to disable the clock
		# PSU_CRL_APB_AMS_REF_CTRL_CLKACT                                                 1

		# This register controls this reference clock
		#(OFFSET, MASK, VALUE)      (0XFF5E0108, 0x013F3F07U ,0x01012302U)  */
    mask_write 0XFF5E0108 0x013F3F07 0x01012302
		# : PUT QSPI IN RESET STATE
		# Register : RST_LPD_IOU2 @ 0XFF5E0238</p>

		# Block level reset
		# PSU_CRL_APB_RST_LPD_IOU2_QSPI_RESET                                             1

		# Software control register for the IOU block. Each bit will cause a singl
    # erperipheral or part of the peripheral to be reset.
		#(OFFSET, MASK, VALUE)      (0XFF5E0238, 0x00000001U ,0x00000001U)  */
    mask_write 0XFF5E0238 0x00000001 0x00000001
}

set psu_peripherals_init_data {
		# : COHERENCY
		# : FPD RESET
		# Register : RST_FPD_TOP @ 0XFD1A0100</p>

		# PCIE config reset
		# PSU_CRF_APB_RST_FPD_TOP_PCIE_CFG_RESET                                          0

		# PCIE control block level reset
		# PSU_CRF_APB_RST_FPD_TOP_PCIE_CTRL_RESET                                         0

		# PCIE bridge block level reset (AXI interface)
		# PSU_CRF_APB_RST_FPD_TOP_PCIE_BRIDGE_RESET                                       0

		# GDMA block level reset
		# PSU_CRF_APB_RST_FPD_TOP_GDMA_RESET                                              0

		# Pixel Processor (submodule of GPU) block level reset
		# PSU_CRF_APB_RST_FPD_TOP_GPU_PP0_RESET                                           0

		# Pixel Processor (submodule of GPU) block level reset
		# PSU_CRF_APB_RST_FPD_TOP_GPU_PP1_RESET                                           0

		# GPU block level reset
		# PSU_CRF_APB_RST_FPD_TOP_GPU_RESET                                               0

		# GT block level reset
		# PSU_CRF_APB_RST_FPD_TOP_GT_RESET                                                0

		# FPD Block level software controlled reset
		#(OFFSET, MASK, VALUE)      (0XFD1A0100, 0x000E007CU ,0x00000000U)  */
    mask_write 0XFD1A0100 0x000E007C 0x00000000
		# : RESET BLOCKS
		# : TIMESTAMP
		# Register : RST_LPD_IOU2 @ 0XFF5E0238</p>

		# Block level reset
		# PSU_CRL_APB_RST_LPD_IOU2_TIMESTAMP_RESET                                        0

		# Block level reset
		# PSU_CRL_APB_RST_LPD_IOU2_IOU_CC_RESET                                           0

		# Block level reset
		# PSU_CRL_APB_RST_LPD_IOU2_ADMA_RESET                                             0

		# Software control register for the IOU block. Each bit will cause a singl
    # erperipheral or part of the peripheral to be reset.
		#(OFFSET, MASK, VALUE)      (0XFF5E0238, 0x001A0000U ,0x00000000U)  */
    mask_write 0XFF5E0238 0x001A0000 0x00000000
		# Register : RST_LPD_TOP @ 0XFF5E023C</p>

		# Reset entire full power domain.
		# PSU_CRL_APB_RST_LPD_TOP_FPD_RESET                                               0

		# LPD SWDT
		# PSU_CRL_APB_RST_LPD_TOP_LPD_SWDT_RESET                                          0

		# Sysmonitor reset
		# PSU_CRL_APB_RST_LPD_TOP_SYSMON_RESET                                            0

		# Real Time Clock reset
		# PSU_CRL_APB_RST_LPD_TOP_RTC_RESET                                               0

		# APM reset
		# PSU_CRL_APB_RST_LPD_TOP_APM_RESET                                               0

		# IPI reset
		# PSU_CRL_APB_RST_LPD_TOP_IPI_RESET                                               0

		# reset entire RPU power island
		# PSU_CRL_APB_RST_LPD_TOP_RPU_PGE_RESET                                           0

		# reset ocm
		# PSU_CRL_APB_RST_LPD_TOP_OCM_RESET                                               0

		# Software control register for the LPD block.
		#(OFFSET, MASK, VALUE)      (0XFF5E023C, 0x0093C018U ,0x00000000U)  */
    mask_write 0XFF5E023C 0x0093C018 0x00000000
		# : ENET
		# : QSPI
		# Register : RST_LPD_IOU2 @ 0XFF5E0238</p>

		# Block level reset
		# PSU_CRL_APB_RST_LPD_IOU2_QSPI_RESET                                             0

		# Software control register for the IOU block. Each bit will cause a singl
    # erperipheral or part of the peripheral to be reset.
		#(OFFSET, MASK, VALUE)      (0XFF5E0238, 0x00000001U ,0x00000000U)  */
    mask_write 0XFF5E0238 0x00000001 0x00000000
		# : QSPI TAP DELAY
		# Register : IOU_TAPDLY_BYPASS @ 0XFF180390</p>

		# 0: Do not by pass the tap delays on the Rx clock signal of LQSPI 1: Bypa
    # ss the Tap delay on the Rx clock signal of LQSPI
		# PSU_IOU_SLCR_IOU_TAPDLY_BYPASS_LQSPI_RX                                         1

		# IOU tap delay bypass for the LQSPI and NAND controllers
		#(OFFSET, MASK, VALUE)      (0XFF180390, 0x00000004U ,0x00000004U)  */
    mask_write 0XFF180390 0x00000004 0x00000004
		# : NAND
		# : USB RESET
		# Register : RST_LPD_TOP @ 0XFF5E023C</p>

		# USB 0 reset for control registers
		# PSU_CRL_APB_RST_LPD_TOP_USB0_APB_RESET                                          0

		# Software control register for the LPD block.
		#(OFFSET, MASK, VALUE)      (0XFF5E023C, 0x00000400U ,0x00000000U)  */
    mask_write 0XFF5E023C 0x00000400 0x00000000
		# : SD
		# Register : RST_LPD_IOU2 @ 0XFF5E0238</p>

		# Block level reset
		# PSU_CRL_APB_RST_LPD_IOU2_SDIO0_RESET                                            0

		# Software control register for the IOU block. Each bit will cause a singl
    # erperipheral or part of the peripheral to be reset.
		#(OFFSET, MASK, VALUE)      (0XFF5E0238, 0x00000020U ,0x00000000U)  */
    mask_write 0XFF5E0238 0x00000020 0x00000000
		# Register : CTRL_REG_SD @ 0XFF180310</p>

		# SD or eMMC selection on SDIO0 0: SD enabled 1: eMMC enabled
		# PSU_IOU_SLCR_CTRL_REG_SD_SD0_EMMC_SEL                                           1

		# SD eMMC selection
		#(OFFSET, MASK, VALUE)      (0XFF180310, 0x00000001U ,0x00000001U)  */
    mask_write 0XFF180310 0x00000001 0x00000001
		# Register : SD_CONFIG_REG2 @ 0XFF180320</p>

		# Should be set based on the final product usage 00 - Removable SCard Slot
    #  01 - Embedded Slot for One Device 10 - Shared Bus Slot 11 - Reserved
		# PSU_IOU_SLCR_SD_CONFIG_REG2_SD0_SLOTTYPE                                        1

		# 8-bit Support for Embedded Device 1: The Core supports 8-bit Interface 0
    # : Supports only 4-bit SD Interface
		# PSU_IOU_SLCR_SD_CONFIG_REG2_SD0_8BIT                                            1

		# 1.8V Support 1: 1.8V supported 0: 1.8V not supported support
		# PSU_IOU_SLCR_SD_CONFIG_REG2_SD0_1P8V                                            1

		# 3.0V Support 1: 3.0V supported 0: 3.0V not supported support
		# PSU_IOU_SLCR_SD_CONFIG_REG2_SD0_3P0V                                            0

		# 3.3V Support 1: 3.3V supported 0: 3.3V not supported support
		# PSU_IOU_SLCR_SD_CONFIG_REG2_SD0_3P3V                                            1

		# SD Config Register 2
		#(OFFSET, MASK, VALUE)      (0XFF180320, 0x00003384U ,0x00001284U)  */
    mask_write 0XFF180320 0x00003384 0x00001284
		# : SD0 BASE CLOCK
		# Register : SD_CONFIG_REG1 @ 0XFF18031C</p>

		# Base Clock Frequency for SD Clock. This is the frequency of the xin_clk.
		# PSU_IOU_SLCR_SD_CONFIG_REG1_SD0_BASECLK                                         0xc8

		# Configures the Number of Taps (Phases) of the rxclk_in that is supported
    #  for auto tuning mode
		# PSU_IOU_SLCR_SD_CONFIG_REG1_SD0_TUNIGCOUNT                                      0x28

		# SD Config Register 1
		#(OFFSET, MASK, VALUE)      (0XFF18031C, 0x00007FFEU ,0x00006450U)  */
    mask_write 0XFF18031C 0x00007FFE 0x00006450
		# Register : SD_DLL_CTRL @ 0XFF180358</p>

		# Reserved.
		# PSU_IOU_SLCR_SD_DLL_CTRL_RESERVED_2                                             1

		# SDIO status register
		#(OFFSET, MASK, VALUE)      (0XFF180358, 0x00080000U ,0x00080000U)  */
    mask_write 0XFF180358 0x00080000 0x00080000
		# : SD0 RETUNER
		# Register : SD_CONFIG_REG3 @ 0XFF180324</p>

		# This is the Timer Count for Re-Tuning Timer for Re-Tuning Mode 1 to 3. S
    # etting to 4'b0 disables Re-Tuning Timer. 0h - Get information via other
    # source 1h = 1 seconds 2h = 2 seconds 3h = 4 seconds 4h = 8 seconds -- n
    # = 2(n-1) seconds -- Bh = 1024 seconds Fh - Ch = Reserved
		# PSU_IOU_SLCR_SD_CONFIG_REG3_SD0_RETUNETMR                                       0X0

		# SD Config Register 3
		#(OFFSET, MASK, VALUE)      (0XFF180324, 0x000003C0U ,0x00000000U)  */
    mask_write 0XFF180324 0x000003C0 0x00000000
		# : CAN
		# : I2C
		# Register : RST_LPD_IOU2 @ 0XFF5E0238</p>

		# Block level reset
		# PSU_CRL_APB_RST_LPD_IOU2_I2C0_RESET                                             0

		# Software control register for the IOU block. Each bit will cause a singl
    # erperipheral or part of the peripheral to be reset.
		#(OFFSET, MASK, VALUE)      (0XFF5E0238, 0x00000200U ,0x00000000U)  */
    mask_write 0XFF5E0238 0x00000200 0x00000000
		# : SWDT
		# : SPI
		# : TTC
		# : UART
		# Register : RST_LPD_IOU2 @ 0XFF5E0238</p>

		# Block level reset
		# PSU_CRL_APB_RST_LPD_IOU2_UART0_RESET                                            0

		# Block level reset
		# PSU_CRL_APB_RST_LPD_IOU2_UART1_RESET                                            0

		# Software control register for the IOU block. Each bit will cause a singl
    # erperipheral or part of the peripheral to be reset.
		#(OFFSET, MASK, VALUE)      (0XFF5E0238, 0x00000006U ,0x00000000U)  */
    mask_write 0XFF5E0238 0x00000006 0x00000000
		# : UART BAUD RATE
		# Register : Baud_rate_divider_reg0 @ 0XFF000034</p>

		# Baud rate divider value: 0 - 3: ignored 4 - 255: Baud rate
		# PSU_UART0_BAUD_RATE_DIVIDER_REG0_BDIV                                           0x6

		# Baud Rate Divider Register
		#(OFFSET, MASK, VALUE)      (0XFF000034, 0x000000FFU ,0x00000006U)  */
    mask_write 0XFF000034 0x000000FF 0x00000006
		# Register : Baud_rate_gen_reg0 @ 0XFF000018</p>

		# Baud Rate Clock Divisor Value: 0: Disables baud_sample 1: Clock divisor
    # bypass (baud_sample = sel_clk) 2 - 65535: baud_sample
		# PSU_UART0_BAUD_RATE_GEN_REG0_CD                                                 0x7c

		# Baud Rate Generator Register.
		#(OFFSET, MASK, VALUE)      (0XFF000018, 0x0000FFFFU ,0x0000007CU)  */
    mask_write 0XFF000018 0x0000FFFF 0x0000007C
		# Register : Control_reg0 @ 0XFF000000</p>

		# Stop transmitter break: 0: no affect 1: stop transmission of the break a
    # fter a minimum of one character length and transmit a high level during
    # 12 bit periods. It can be set regardless of the value of STTBRK.
		# PSU_UART0_CONTROL_REG0_STPBRK                                                   0x0

		# Start transmitter break: 0: no affect 1: start to transmit a break after
    #  the characters currently present in the FIFO and the transmit shift reg
    # ister have been transmitted. It can only be set if STPBRK (Stop transmit
    # ter break) is not high.
		# PSU_UART0_CONTROL_REG0_STTBRK                                                   0x0

		# Restart receiver timeout counter: 1: receiver timeout counter is restart
    # ed. This bit is self clearing once the restart has completed.
		# PSU_UART0_CONTROL_REG0_RSTTO                                                    0x0

		# Transmit disable: 0: enable transmitter 1: disable transmitter
		# PSU_UART0_CONTROL_REG0_TXDIS                                                    0x0

		# Transmit enable: 0: disable transmitter 1: enable transmitter, provided
    # the TXDIS field is set to 0.
		# PSU_UART0_CONTROL_REG0_TXEN                                                     0x1

		# Receive disable: 0: enable 1: disable, regardless of the value of RXEN
		# PSU_UART0_CONTROL_REG0_RXDIS                                                    0x0

		# Receive enable: 0: disable 1: enable When set to one, the receiver logic
    #  is enabled, provided the RXDIS field is set to zero.
		# PSU_UART0_CONTROL_REG0_RXEN                                                     0x1

		# Software reset for Tx data path: 0: no affect 1: transmitter logic is re
    # set and all pending transmitter data is discarded This bit is self clear
    # ing once the reset has completed.
		# PSU_UART0_CONTROL_REG0_TXRES                                                    0x1

		# Software reset for Rx data path: 0: no affect 1: receiver logic is reset
    #  and all pending receiver data is discarded. This bit is self clearing o
    # nce the reset has completed.
		# PSU_UART0_CONTROL_REG0_RXRES                                                    0x1

		# UART Control Register
		#(OFFSET, MASK, VALUE)      (0XFF000000, 0x000001FFU ,0x00000017U)  */
    mask_write 0XFF000000 0x000001FF 0x00000017
		# Register : mode_reg0 @ 0XFF000004</p>

		# Channel mode: Defines the mode of operation of the UART. 00: normal 01:
    # automatic echo 10: local loopback 11: remote loopback
		# PSU_UART0_MODE_REG0_CHMODE                                                      0x0

		# Number of stop bits: Defines the number of stop bits to detect on receiv
    # e and to generate on transmit. 00: 1 stop bit 01: 1.5 stop bits 10: 2 st
    # op bits 11: reserved
		# PSU_UART0_MODE_REG0_NBSTOP                                                      0x0

		# Parity type select: Defines the expected parity to check on receive and
    # the parity to generate on transmit. 000: even parity 001: odd parity 010
    # : forced to 0 parity (space) 011: forced to 1 parity (mark) 1xx: no pari
    # ty
		# PSU_UART0_MODE_REG0_PAR                                                         0x4

		# Character length select: Defines the number of bits in each character. 1
    # 1: 6 bits 10: 7 bits 0x: 8 bits
		# PSU_UART0_MODE_REG0_CHRL                                                        0x0

		# Clock source select: This field defines whether a pre-scalar of 8 is app
    # lied to the baud rate generator input clock. 0: clock source is uart_ref
    # _clk 1: clock source is uart_ref_clk/8
		# PSU_UART0_MODE_REG0_CLKS                                                        0x0

		# UART Mode Register
		#(OFFSET, MASK, VALUE)      (0XFF000004, 0x000003FFU ,0x00000020U)  */
    mask_write 0XFF000004 0x000003FF 0x00000020
		# Register : Baud_rate_divider_reg0 @ 0XFF010034</p>

		# Baud rate divider value: 0 - 3: ignored 4 - 255: Baud rate
		# PSU_UART1_BAUD_RATE_DIVIDER_REG0_BDIV                                           0x6

		# Baud Rate Divider Register
		#(OFFSET, MASK, VALUE)      (0XFF010034, 0x000000FFU ,0x00000006U)  */
    mask_write 0XFF010034 0x000000FF 0x00000006
		# Register : Baud_rate_gen_reg0 @ 0XFF010018</p>

		# Baud Rate Clock Divisor Value: 0: Disables baud_sample 1: Clock divisor
    # bypass (baud_sample = sel_clk) 2 - 65535: baud_sample
		# PSU_UART1_BAUD_RATE_GEN_REG0_CD                                                 0x7c

		# Baud Rate Generator Register.
		#(OFFSET, MASK, VALUE)      (0XFF010018, 0x0000FFFFU ,0x0000007CU)  */
    mask_write 0XFF010018 0x0000FFFF 0x0000007C
		# Register : Control_reg0 @ 0XFF010000</p>

		# Stop transmitter break: 0: no affect 1: stop transmission of the break a
    # fter a minimum of one character length and transmit a high level during
    # 12 bit periods. It can be set regardless of the value of STTBRK.
		# PSU_UART1_CONTROL_REG0_STPBRK                                                   0x0

		# Start transmitter break: 0: no affect 1: start to transmit a break after
    #  the characters currently present in the FIFO and the transmit shift reg
    # ister have been transmitted. It can only be set if STPBRK (Stop transmit
    # ter break) is not high.
		# PSU_UART1_CONTROL_REG0_STTBRK                                                   0x0

		# Restart receiver timeout counter: 1: receiver timeout counter is restart
    # ed. This bit is self clearing once the restart has completed.
		# PSU_UART1_CONTROL_REG0_RSTTO                                                    0x0

		# Transmit disable: 0: enable transmitter 1: disable transmitter
		# PSU_UART1_CONTROL_REG0_TXDIS                                                    0x0

		# Transmit enable: 0: disable transmitter 1: enable transmitter, provided
    # the TXDIS field is set to 0.
		# PSU_UART1_CONTROL_REG0_TXEN                                                     0x1

		# Receive disable: 0: enable 1: disable, regardless of the value of RXEN
		# PSU_UART1_CONTROL_REG0_RXDIS                                                    0x0

		# Receive enable: 0: disable 1: enable When set to one, the receiver logic
    #  is enabled, provided the RXDIS field is set to zero.
		# PSU_UART1_CONTROL_REG0_RXEN                                                     0x1

		# Software reset for Tx data path: 0: no affect 1: transmitter logic is re
    # set and all pending transmitter data is discarded This bit is self clear
    # ing once the reset has completed.
		# PSU_UART1_CONTROL_REG0_TXRES                                                    0x1

		# Software reset for Rx data path: 0: no affect 1: receiver logic is reset
    #  and all pending receiver data is discarded. This bit is self clearing o
    # nce the reset has completed.
		# PSU_UART1_CONTROL_REG0_RXRES                                                    0x1

		# UART Control Register
		#(OFFSET, MASK, VALUE)      (0XFF010000, 0x000001FFU ,0x00000017U)  */
    mask_write 0XFF010000 0x000001FF 0x00000017
		# Register : mode_reg0 @ 0XFF010004</p>

		# Channel mode: Defines the mode of operation of the UART. 00: normal 01:
    # automatic echo 10: local loopback 11: remote loopback
		# PSU_UART1_MODE_REG0_CHMODE                                                      0x0

		# Number of stop bits: Defines the number of stop bits to detect on receiv
    # e and to generate on transmit. 00: 1 stop bit 01: 1.5 stop bits 10: 2 st
    # op bits 11: reserved
		# PSU_UART1_MODE_REG0_NBSTOP                                                      0x0

		# Parity type select: Defines the expected parity to check on receive and
    # the parity to generate on transmit. 000: even parity 001: odd parity 010
    # : forced to 0 parity (space) 011: forced to 1 parity (mark) 1xx: no pari
    # ty
		# PSU_UART1_MODE_REG0_PAR                                                         0x4

		# Character length select: Defines the number of bits in each character. 1
    # 1: 6 bits 10: 7 bits 0x: 8 bits
		# PSU_UART1_MODE_REG0_CHRL                                                        0x0

		# Clock source select: This field defines whether a pre-scalar of 8 is app
    # lied to the baud rate generator input clock. 0: clock source is uart_ref
    # _clk 1: clock source is uart_ref_clk/8
		# PSU_UART1_MODE_REG0_CLKS                                                        0x0

		# UART Mode Register
		#(OFFSET, MASK, VALUE)      (0XFF010004, 0x000003FFU ,0x00000020U)  */
    mask_write 0XFF010004 0x000003FF 0x00000020
		# : GPIO
		# Register : RST_LPD_IOU2 @ 0XFF5E0238</p>

		# Block level reset
		# PSU_CRL_APB_RST_LPD_IOU2_GPIO_RESET                                             0

		# Software control register for the IOU block. Each bit will cause a singl
    # erperipheral or part of the peripheral to be reset.
		#(OFFSET, MASK, VALUE)      (0XFF5E0238, 0x00040000U ,0x00000000U)  */
    mask_write 0XFF5E0238 0x00040000 0x00000000
		# : ADMA TZ
		# Register : slcr_adma @ 0XFF4B0024</p>

		# TrustZone Classification for ADMA
		# PSU_LPD_SLCR_SECURE_SLCR_ADMA_TZ                                                0XFF

		# RPU TrustZone settings
		#(OFFSET, MASK, VALUE)      (0XFF4B0024, 0x000000FFU ,0x000000FFU)  */
    mask_write 0XFF4B0024 0x000000FF 0x000000FF
		# : CSU TAMPERING
		# : CSU TAMPER STATUS
		# Register : tamper_status @ 0XFFCA5000</p>

		# CSU regsiter
		# PSU_CSU_TAMPER_STATUS_TAMPER_0                                                  0

		# External MIO
		# PSU_CSU_TAMPER_STATUS_TAMPER_1                                                  0

		# JTAG toggle detect
		# PSU_CSU_TAMPER_STATUS_TAMPER_2                                                  0

		# PL SEU error
		# PSU_CSU_TAMPER_STATUS_TAMPER_3                                                  0

		# AMS over temperature alarm for LPD
		# PSU_CSU_TAMPER_STATUS_TAMPER_4                                                  0

		# AMS over temperature alarm for APU
		# PSU_CSU_TAMPER_STATUS_TAMPER_5                                                  0

		# AMS voltage alarm for VCCPINT_FPD
		# PSU_CSU_TAMPER_STATUS_TAMPER_6                                                  0

		# AMS voltage alarm for VCCPINT_LPD
		# PSU_CSU_TAMPER_STATUS_TAMPER_7                                                  0

		# AMS voltage alarm for VCCPAUX
		# PSU_CSU_TAMPER_STATUS_TAMPER_8                                                  0

		# AMS voltage alarm for DDRPHY
		# PSU_CSU_TAMPER_STATUS_TAMPER_9                                                  0

		# AMS voltage alarm for PSIO bank 0/1/2
		# PSU_CSU_TAMPER_STATUS_TAMPER_10                                                 0

		# AMS voltage alarm for PSIO bank 3 (dedicated pins)
		# PSU_CSU_TAMPER_STATUS_TAMPER_11                                                 0

		# AMS voltaage alarm for GT
		# PSU_CSU_TAMPER_STATUS_TAMPER_12                                                 0

		# Tamper Response Status
		#(OFFSET, MASK, VALUE)      (0XFFCA5000, 0x00001FFFU ,0x00000000U)  */
    mask_write 0XFFCA5000 0x00001FFF 0x00000000
		# : CSU TAMPER RESPONSE
		# : CPU QOS DEFAULT
		# Register : ACE_CTRL @ 0XFD5C0060</p>

		# Set ACE outgoing AWQOS value
		# PSU_APU_ACE_CTRL_AWQOS                                                          0X0

		# Set ACE outgoing ARQOS value
		# PSU_APU_ACE_CTRL_ARQOS                                                          0X0

		# ACE Control Register
		#(OFFSET, MASK, VALUE)      (0XFD5C0060, 0x000F000FU ,0x00000000U)  */
    mask_write 0XFD5C0060 0x000F000F 0x00000000
		# : ENABLES RTC SWITCH TO BATTERY WHEN VCC_PSAUX IS NOT AVAILABLE
		# Register : CONTROL @ 0XFFA60040</p>

		# Enables the RTC. By writing a 0 to this bit, RTC will be powered off and
    #  the only module that potentially draws current from the battery will be
    #  BBRAM. The value read through this bit does not necessarily reflect whe
    # ther RTC is enabled or not. It is expected that RTC is enabled every tim
    # e it is being configured. If RTC is not used in the design, FSBL will di
    # sable it by writing a 0 to this bit.
		# PSU_RTC_CONTROL_BATTERY_DISABLE                                                 0X1

		# This register controls various functionalities within the RTC
		#(OFFSET, MASK, VALUE)      (0XFFA60040, 0x80000000U ,0x80000000U)  */
    mask_write 0XFFA60040 0x80000000 0x80000000
		# : TIMESTAMP COUNTER
		# Register : base_frequency_ID_register @ 0XFF260020</p>

		# Frequency in number of ticks per second. Valid range from 10 MHz to 100
    # MHz.
		# PSU_IOU_SCNTRS_BASE_FREQUENCY_ID_REGISTER_FREQ                                  0x2faf080

		# Program this register to match the clock frequency of the timestamp gene
    # rator, in ticks per second. For example, for a 50 MHz clock, program 0x0
    # 2FAF080. This register is not accessible to the read-only programming in
    # terface.
		#(OFFSET, MASK, VALUE)      (0XFF260020, 0xFFFFFFFFU ,0x02FAF080U)  */
    mask_write 0XFF260020 0xFFFFFFFF 0x02FAF080
		# Register : counter_control_register @ 0XFF260000</p>

		# Enable 0: The counter is disabled and not incrementing. 1: The counter i
    # s enabled and is incrementing.
		# PSU_IOU_SCNTRS_COUNTER_CONTROL_REGISTER_EN                                      0x1

		# Controls the counter increments. This register is not accessible to the
    # read-only programming interface.
		#(OFFSET, MASK, VALUE)      (0XFF260000, 0x00000001U ,0x00000001U)  */
    mask_write 0XFF260000 0x00000001 0x00000001
		# : TTC SRC SELECT
		# : USB RESET
		# : USB0 RESET
		# : DIR MODE BANK 0
		# : DIR MODE BANK 1
		# : DIR MODE BANK 2
		# Register : DIRM_2 @ 0XFF0A0284</p>

		# Operation is the same as DIRM_0[DIRECTION_0]
		# PSU_GPIO_DIRM_2_DIRECTION_2                                                     0x1000

		# Direction mode (GPIO Bank2, MIO)
		#(OFFSET, MASK, VALUE)      (0XFF0A0284, 0x03FFFFFFU ,0x00001000U)  */
    mask_write 0XFF0A0284 0x03FFFFFF 0x00001000
		# : OUTPUT ENABLE BANK 0
		# : OUTPUT ENABLE BANK 1
		# : OUTPUT ENABLE BANK 2
		# Register : OEN_2 @ 0XFF0A0288</p>

		# Operation is the same as OEN_0[OP_ENABLE_0]
		# PSU_GPIO_OEN_2_OP_ENABLE_2                                                      0x1000

		# Output enable (GPIO Bank2, MIO)
		#(OFFSET, MASK, VALUE)      (0XFF0A0288, 0x03FFFFFFU ,0x00001000U)  */
    mask_write 0XFF0A0288 0x03FFFFFF 0x00001000
		# : MASK_DATA_0_LSW LOW BANK [15:0]
		# : MASK_DATA_0_MSW LOW BANK [25:16]
		# : MASK_DATA_1_LSW LOW BANK [41:26]
		# : MASK_DATA_1_MSW HIGH BANK [51:42]
		# : MASK_DATA_1_LSW HIGH BANK [67:52]
		# Register : MASK_DATA_2_LSW @ 0XFF0A0010</p>

		# Operation is the same as MASK_DATA_0_LSW[MASK_0_LSW]
		# PSU_GPIO_MASK_DATA_2_LSW_MASK_2_LSW                                             0xefff

		# Operation is the same as MASK_DATA_0_LSW[DATA_0_LSW]
		# PSU_GPIO_MASK_DATA_2_LSW_DATA_2_LSW                                             0x1000

		# Maskable Output Data (GPIO Bank2, MIO, Lower 16 bits)
		#(OFFSET, MASK, VALUE)      (0XFF0A0010, 0xFFFFFFFFU ,0xEFFF1000U)  */
    mask_write 0XFF0A0010 0xFFFFFFFF 0xEFFF1000
		# : MASK_DATA_1_LSW HIGH BANK [77:68]
		# : ADD 1 MS DELAY
    mask_delay 0x00000000 1
		# : MASK_DATA_0_LSW LOW BANK [15:0]
		# : MASK_DATA_0_MSW LOW BANK [25:16]
		# : MASK_DATA_1_LSW LOW BANK [41:26]
		# : MASK_DATA_1_MSW HIGH BANK [51:42]
		# : MASK_DATA_1_LSW HIGH BANK [67:52]
		# Register : MASK_DATA_2_LSW @ 0XFF0A0010</p>

		# Operation is the same as MASK_DATA_0_LSW[MASK_0_LSW]
		# PSU_GPIO_MASK_DATA_2_LSW_MASK_2_LSW                                             0xefff

		# Operation is the same as MASK_DATA_0_LSW[DATA_0_LSW]
		# PSU_GPIO_MASK_DATA_2_LSW_DATA_2_LSW                                             0x0

		# Maskable Output Data (GPIO Bank2, MIO, Lower 16 bits)
		#(OFFSET, MASK, VALUE)      (0XFF0A0010, 0xFFFFFFFFU ,0xEFFF0000U)  */
    mask_write 0XFF0A0010 0xFFFFFFFF 0xEFFF0000
		# : MASK_DATA_1_LSW HIGH BANK [77:68]
		# : ADD 5 MS DELAY
    mask_delay 0x00000000 5
		# : MASK_DATA_0_LSW LOW BANK [15:0]
		# : MASK_DATA_0_MSW LOW BANK [25:16]
		# : MASK_DATA_1_LSW LOW BANK [41:26]
		# : MASK_DATA_1_MSW HIGH BANK [51:42]
		# : MASK_DATA_1_LSW HIGH BANK [67:52]
		# Register : MASK_DATA_2_LSW @ 0XFF0A0010</p>

		# Operation is the same as MASK_DATA_0_LSW[MASK_0_LSW]
		# PSU_GPIO_MASK_DATA_2_LSW_MASK_2_LSW                                             0xefff

		# Operation is the same as MASK_DATA_0_LSW[DATA_0_LSW]
		# PSU_GPIO_MASK_DATA_2_LSW_DATA_2_LSW                                             0x1000

		# Maskable Output Data (GPIO Bank2, MIO, Lower 16 bits)
		#(OFFSET, MASK, VALUE)      (0XFF0A0010, 0xFFFFFFFFU ,0xEFFF1000U)  */
    mask_write 0XFF0A0010 0xFFFFFFFF 0xEFFF1000
		# : MASK_DATA_1_LSW HIGH BANK [77:68]
		# : GPIO POLARITY INITIALIZATION
}

set psu_post_config_data {
		# : POST_CONFIG
}

set psu_peripherals_powerdwn_data {
		# : POWER DOWN REQUEST INTERRUPT ENABLE
		# : POWER DOWN TRIGGER
}

set psu_lpd_xppu_data {
		# : MASTER ID LIST
		# : APERTURE PERMISIION LIST
		# : APERTURE NAME: UART0, START ADDRESS: FF000000, END ADDRESS: FF00FFFF
		# : APERTURE NAME: UART1, START ADDRESS: FF010000, END ADDRESS: FF01FFFF
		# : APERTURE NAME: I2C0, START ADDRESS: FF020000, END ADDRESS: FF02FFFF
		# : APERTURE NAME: I2C1, START ADDRESS: FF030000, END ADDRESS: FF03FFFF
		# : APERTURE NAME: SPI0, START ADDRESS: FF040000, END ADDRESS: FF04FFFF
		# : APERTURE NAME: SPI1, START ADDRESS: FF050000, END ADDRESS: FF05FFFF
		# : APERTURE NAME: CAN0, START ADDRESS: FF060000, END ADDRESS: FF06FFFF
		# : APERTURE NAME: CAN1, START ADDRESS: FF070000, END ADDRESS: FF07FFFF
		# : APERTURE NAME: RPU_UNUSED_12, START ADDRESS: FF080000, END ADDRESS: FF09FFFF
		# : APERTURE NAME: RPU_UNUSED_12, START ADDRESS: FF080000, END ADDRESS: FF09FFFF
		# : APERTURE NAME: GPIO, START ADDRESS: FF0A0000, END ADDRESS: FF0AFFFF
		# : APERTURE NAME: GEM0, START ADDRESS: FF0B0000, END ADDRESS: FF0BFFFF
		# : APERTURE NAME: GEM1, START ADDRESS: FF0C0000, END ADDRESS: FF0CFFFF
		# : APERTURE NAME: GEM2, START ADDRESS: FF0D0000, END ADDRESS: FF0DFFFF
		# : APERTURE NAME: GEM3, START ADDRESS: FF0E0000, END ADDRESS: FF0EFFFF
		# : APERTURE NAME: QSPI, START ADDRESS: FF0F0000, END ADDRESS: FF0FFFFF
		# : APERTURE NAME: NAND, START ADDRESS: FF100000, END ADDRESS: FF10FFFF
		# : APERTURE NAME: TTC0, START ADDRESS: FF110000, END ADDRESS: FF11FFFF
		# : APERTURE NAME: TTC1, START ADDRESS: FF120000, END ADDRESS: FF12FFFF
		# : APERTURE NAME: TTC2, START ADDRESS: FF130000, END ADDRESS: FF13FFFF
		# : APERTURE NAME: TTC3, START ADDRESS: FF140000, END ADDRESS: FF14FFFF
		# : APERTURE NAME: SWDT, START ADDRESS: FF150000, END ADDRESS: FF15FFFF
		# : APERTURE NAME: SD0, START ADDRESS: FF160000, END ADDRESS: FF16FFFF
		# : APERTURE NAME: SD1, START ADDRESS: FF170000, END ADDRESS: FF17FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SLCR, START ADDRESS: FF180000, END ADDRESS: FF23FFFF
		# : APERTURE NAME: IOU_SECURE_SLCR, START ADDRESS: FF240000, END ADDRESS: FF24FFFF
		# : APERTURE NAME: IOU_SCNTR, START ADDRESS: FF250000, END ADDRESS: FF25FFFF
		# : APERTURE NAME: IOU_SCNTRS, START ADDRESS: FF260000, END ADDRESS: FF26FFFF
		# : APERTURE NAME: RPU_UNUSED_11, START ADDRESS: FF270000, END ADDRESS: FF2AFFFF
		# : APERTURE NAME: RPU_UNUSED_11, START ADDRESS: FF270000, END ADDRESS: FF2AFFFF
		# : APERTURE NAME: RPU_UNUSED_11, START ADDRESS: FF270000, END ADDRESS: FF2AFFFF
		# : APERTURE NAME: RPU_UNUSED_11, START ADDRESS: FF270000, END ADDRESS: FF2AFFFF
		# : APERTURE NAME: LPD_UNUSED_14, START ADDRESS: FF2B0000, END ADDRESS: FF2FFFFF
		# : APERTURE NAME: LPD_UNUSED_14, START ADDRESS: FF2B0000, END ADDRESS: FF2FFFFF
		# : APERTURE NAME: LPD_UNUSED_14, START ADDRESS: FF2B0000, END ADDRESS: FF2FFFFF
		# : APERTURE NAME: LPD_UNUSED_14, START ADDRESS: FF2B0000, END ADDRESS: FF2FFFFF
		# : APERTURE NAME: LPD_UNUSED_14, START ADDRESS: FF2B0000, END ADDRESS: FF2FFFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_CTRL, START ADDRESS: FF380000, END ADDRESS: FF3FFFFF
		# : APERTURE NAME: IPI_CTRL, START ADDRESS: FF380000, END ADDRESS: FF3FFFFF
		# : APERTURE NAME: IPI_CTRL, START ADDRESS: FF380000, END ADDRESS: FF3FFFFF
		# : APERTURE NAME: IPI_CTRL, START ADDRESS: FF380000, END ADDRESS: FF3FFFFF
		# : APERTURE NAME: IPI_CTRL, START ADDRESS: FF380000, END ADDRESS: FF3FFFFF
		# : APERTURE NAME: IPI_CTRL, START ADDRESS: FF380000, END ADDRESS: FF3FFFFF
		# : APERTURE NAME: IPI_CTRL, START ADDRESS: FF380000, END ADDRESS: FF3FFFFF
		# : APERTURE NAME: IPI_CTRL, START ADDRESS: FF380000, END ADDRESS: FF3FFFFF
		# : APERTURE NAME: LPD_UNUSED_1, START ADDRESS: FF400000, END ADDRESS: FF40FFFF
		# : APERTURE NAME: LPD_SLCR, START ADDRESS: FF410000, END ADDRESS: FF4AFFFF
		# : APERTURE NAME: LPD_SLCR, START ADDRESS: FF410000, END ADDRESS: FF4AFFFF
		# : APERTURE NAME: LPD_SLCR, START ADDRESS: FF410000, END ADDRESS: FF4AFFFF
		# : APERTURE NAME: LPD_SLCR, START ADDRESS: FF410000, END ADDRESS: FF4AFFFF
		# : APERTURE NAME: LPD_SLCR, START ADDRESS: FF410000, END ADDRESS: FF4AFFFF
		# : APERTURE NAME: LPD_SLCR, START ADDRESS: FF410000, END ADDRESS: FF4AFFFF
		# : APERTURE NAME: LPD_SLCR, START ADDRESS: FF410000, END ADDRESS: FF4AFFFF
		# : APERTURE NAME: LPD_SLCR, START ADDRESS: FF410000, END ADDRESS: FF4AFFFF
		# : APERTURE NAME: LPD_SLCR, START ADDRESS: FF410000, END ADDRESS: FF4AFFFF
		# : APERTURE NAME: LPD_SLCR, START ADDRESS: FF410000, END ADDRESS: FF4AFFFF
		# : APERTURE NAME: LPD_SLCR_SECURE, START ADDRESS: FF4B0000, END ADDRESS: FF4DFFFF
		# : APERTURE NAME: LPD_SLCR_SECURE, START ADDRESS: FF4B0000, END ADDRESS: FF4DFFFF
		# : APERTURE NAME: LPD_SLCR_SECURE, START ADDRESS: FF4B0000, END ADDRESS: FF4DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: LPD_UNUSED_2, START ADDRESS: FF4E0000, END ADDRESS: FF5DFFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: CRL_APB, START ADDRESS: FF5E0000, END ADDRESS: FF85FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: LPD_UNUSED_3, START ADDRESS: FF860000, END ADDRESS: FF95FFFF
		# : APERTURE NAME: OCM_SLCR, START ADDRESS: FF960000, END ADDRESS: FF96FFFF
		# : APERTURE NAME: LPD_UNUSED_4, START ADDRESS: FF970000, END ADDRESS: FF97FFFF
		# : APERTURE NAME: LPD_XPPU, START ADDRESS: FF980000, END ADDRESS: FF99FFFF
		# : APERTURE NAME: RPU, START ADDRESS: FF9A0000, END ADDRESS: FF9AFFFF
		# : APERTURE NAME: AFIFM6, START ADDRESS: FF9B0000, END ADDRESS: FF9BFFFF
		# : APERTURE NAME: LPD_XPPU_SINK, START ADDRESS: FF9C0000, END ADDRESS: FF9CFFFF
		# : APERTURE NAME: USB3_0, START ADDRESS: FF9D0000, END ADDRESS: FF9DFFFF
		# : APERTURE NAME: USB3_1, START ADDRESS: FF9E0000, END ADDRESS: FF9EFFFF
		# : APERTURE NAME: LPD_UNUSED_5, START ADDRESS: FF9F0000, END ADDRESS: FF9FFFFF
		# : APERTURE NAME: APM0, START ADDRESS: FFA00000, END ADDRESS: FFA0FFFF
		# : APERTURE NAME: APM1, START ADDRESS: FFA10000, END ADDRESS: FFA1FFFF
		# : APERTURE NAME: APM_INTC_IOU, START ADDRESS: FFA20000, END ADDRESS: FFA2FFFF
		# : APERTURE NAME: APM_FPD_LPD, START ADDRESS: FFA30000, END ADDRESS: FFA3FFFF
		# : APERTURE NAME: LPD_UNUSED_6, START ADDRESS: FFA40000, END ADDRESS: FFA4FFFF
		# : APERTURE NAME: AMS, START ADDRESS: FFA50000, END ADDRESS: FFA5FFFF
		# : APERTURE NAME: RTC, START ADDRESS: FFA60000, END ADDRESS: FFA6FFFF
		# : APERTURE NAME: OCM_XMPU_CFG, START ADDRESS: FFA70000, END ADDRESS: FFA7FFFF
		# : APERTURE NAME: ADMA_0, START ADDRESS: FFA80000, END ADDRESS: FFA8FFFF
		# : APERTURE NAME: ADMA_1, START ADDRESS: FFA90000, END ADDRESS: FFA9FFFF
		# : APERTURE NAME: ADMA_2, START ADDRESS: FFAA0000, END ADDRESS: FFAAFFFF
		# : APERTURE NAME: ADMA_3, START ADDRESS: FFAB0000, END ADDRESS: FFABFFFF
		# : APERTURE NAME: ADMA_4, START ADDRESS: FFAC0000, END ADDRESS: FFACFFFF
		# : APERTURE NAME: ADMA_5, START ADDRESS: FFAD0000, END ADDRESS: FFADFFFF
		# : APERTURE NAME: ADMA_6, START ADDRESS: FFAE0000, END ADDRESS: FFAEFFFF
		# : APERTURE NAME: ADMA_7, START ADDRESS: FFAF0000, END ADDRESS: FFAFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: LPD_UNUSED_7, START ADDRESS: FFB00000, END ADDRESS: FFBFFFFF
		# : APERTURE NAME: CSU_ROM, START ADDRESS: FFC00000, END ADDRESS: FFC1FFFF
		# : APERTURE NAME: CSU_ROM, START ADDRESS: FFC00000, END ADDRESS: FFC1FFFF
		# : APERTURE NAME: CSU_LOCAL, START ADDRESS: FFC20000, END ADDRESS: FFC2FFFF
		# : APERTURE NAME: PUF, START ADDRESS: FFC30000, END ADDRESS: FFC3FFFF
		# : APERTURE NAME: CSU_RAM, START ADDRESS: FFC40000, END ADDRESS: FFC5FFFF
		# : APERTURE NAME: CSU_RAM, START ADDRESS: FFC40000, END ADDRESS: FFC5FFFF
		# : APERTURE NAME: CSU_IOMODULE, START ADDRESS: FFC60000, END ADDRESS: FFC7FFFF
		# : APERTURE NAME: CSU_IOMODULE, START ADDRESS: FFC60000, END ADDRESS: FFC7FFFF
		# : APERTURE NAME: CSUDMA, START ADDRESS: FFC80000, END ADDRESS: FFC9FFFF
		# : APERTURE NAME: CSUDMA, START ADDRESS: FFC80000, END ADDRESS: FFC9FFFF
		# : APERTURE NAME: CSU, START ADDRESS: FFCA0000, END ADDRESS: FFCAFFFF
		# : APERTURE NAME: CSU_WDT, START ADDRESS: FFCB0000, END ADDRESS: FFCBFFFF
		# : APERTURE NAME: EFUSE, START ADDRESS: FFCC0000, END ADDRESS: FFCCFFFF
		# : APERTURE NAME: BBRAM, START ADDRESS: FFCD0000, END ADDRESS: FFCDFFFF
		# : APERTURE NAME: RSA_CORE, START ADDRESS: FFCE0000, END ADDRESS: FFCEFFFF
		# : APERTURE NAME: MBISTJTAG, START ADDRESS: FFCF0000, END ADDRESS: FFCFFFFF
		# : APERTURE NAME: PMU_ROM, START ADDRESS: FFD00000, END ADDRESS: FFD3FFFF
		# : APERTURE NAME: PMU_ROM, START ADDRESS: FFD00000, END ADDRESS: FFD3FFFF
		# : APERTURE NAME: PMU_ROM, START ADDRESS: FFD00000, END ADDRESS: FFD3FFFF
		# : APERTURE NAME: PMU_ROM, START ADDRESS: FFD00000, END ADDRESS: FFD3FFFF
		# : APERTURE NAME: PMU_IOMODULE, START ADDRESS: FFD40000, END ADDRESS: FFD5FFFF
		# : APERTURE NAME: PMU_IOMODULE, START ADDRESS: FFD40000, END ADDRESS: FFD5FFFF
		# : APERTURE NAME: PMU_LOCAL, START ADDRESS: FFD60000, END ADDRESS: FFD7FFFF
		# : APERTURE NAME: PMU_LOCAL, START ADDRESS: FFD60000, END ADDRESS: FFD7FFFF
		# : APERTURE NAME: PMU_GLOBAL, START ADDRESS: FFD80000, END ADDRESS: FFDBFFFF
		# : APERTURE NAME: PMU_GLOBAL, START ADDRESS: FFD80000, END ADDRESS: FFDBFFFF
		# : APERTURE NAME: PMU_GLOBAL, START ADDRESS: FFD80000, END ADDRESS: FFDBFFFF
		# : APERTURE NAME: PMU_GLOBAL, START ADDRESS: FFD80000, END ADDRESS: FFDBFFFF
		# : APERTURE NAME: PMU_RAM, START ADDRESS: FFDC0000, END ADDRESS: FFDFFFFF
		# : APERTURE NAME: PMU_RAM, START ADDRESS: FFDC0000, END ADDRESS: FFDFFFFF
		# : APERTURE NAME: PMU_RAM, START ADDRESS: FFDC0000, END ADDRESS: FFDFFFFF
		# : APERTURE NAME: PMU_RAM, START ADDRESS: FFDC0000, END ADDRESS: FFDFFFFF
		# : APERTURE NAME: R5_0_ATCM, START ADDRESS: FFE00000, END ADDRESS: FFE0FFFF
		# : APERTURE NAME: R5_0_ATCM_LOCKSTEP, START ADDRESS: FFE10000, END ADDRESS: FFE1FFFF
		# : APERTURE NAME: R5_0_BTCM, START ADDRESS: FFE20000, END ADDRESS: FFE2FFFF
		# : APERTURE NAME: R5_0_BTCM_LOCKSTEP, START ADDRESS: FFE30000, END ADDRESS: FFE3FFFF
		# : APERTURE NAME: R5_0_INSTRUCTION_CACHE, START ADDRESS: FFE40000, END ADDRESS: FFE4FFFF
		# : APERTURE NAME: R5_0_DATA_CACHE, START ADDRESS: FFE50000, END ADDRESS: FFE5FFFF
		# : APERTURE NAME: LPD_UNUSED_8, START ADDRESS: FFE60000, END ADDRESS: FFE8FFFF
		# : APERTURE NAME: LPD_UNUSED_8, START ADDRESS: FFE60000, END ADDRESS: FFE8FFFF
		# : APERTURE NAME: LPD_UNUSED_8, START ADDRESS: FFE60000, END ADDRESS: FFE8FFFF
		# : APERTURE NAME: R5_1_ATCM_, START ADDRESS: FFE90000, END ADDRESS: FFE9FFFF
		# : APERTURE NAME: RPU_UNUSED_10, START ADDRESS: FFEA0000, END ADDRESS: FFEAFFFF
		# : APERTURE NAME: R5_1_BTCM_, START ADDRESS: FFEB0000, END ADDRESS: FFEBFFFF
		# : APERTURE NAME: R5_1_INSTRUCTION_CACHE, START ADDRESS: FFEC0000, END ADDRESS: FFECFFFF
		# : APERTURE NAME: R5_1_DATA_CACHE, START ADDRESS: FFED0000, END ADDRESS: FFEDFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_9, START ADDRESS: FFEE0000, END ADDRESS: FFFBFFFF
		# : APERTURE NAME: LPD_UNUSED_15, START ADDRESS: FFFD0000, END ADDRESS: FFFFFFFF
		# : APERTURE NAME: LPD_UNUSED_15, START ADDRESS: FFFD0000, END ADDRESS: FFFFFFFF
		# : APERTURE NAME: LPD_UNUSED_15, START ADDRESS: FFFD0000, END ADDRESS: FFFFFFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_1, START ADDRESS: FF310000, END ADDRESS: FF31FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_2, START ADDRESS: FF320000, END ADDRESS: FF32FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_0, START ADDRESS: FF300000, END ADDRESS: FF30FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_7, START ADDRESS: FF340000, END ADDRESS: FF34FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_8, START ADDRESS: FF350000, END ADDRESS: FF35FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_9, START ADDRESS: FF360000, END ADDRESS: FF36FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_10, START ADDRESS: FF370000, END ADDRESS: FF37FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IPI_PMU, START ADDRESS: FF330000, END ADDRESS: FF33FFFF
		# : APERTURE NAME: IOU_GPV, START ADDRESS: FE000000, END ADDRESS: FE0FFFFF
		# : APERTURE NAME: LPD_GPV, START ADDRESS: FE100000, END ADDRESS: FE1FFFFF
		# : APERTURE NAME: USB3_0_XHCI, START ADDRESS: FE200000, END ADDRESS: FE2FFFFF
		# : APERTURE NAME: USB3_1_XHCI, START ADDRESS: FE300000, END ADDRESS: FE3FFFFF
		# : APERTURE NAME: LPD_UNUSED_13, START ADDRESS: FE400000, END ADDRESS: FE7FFFFF
		# : APERTURE NAME: LPD_UNUSED_13, START ADDRESS: FE400000, END ADDRESS: FE7FFFFF
		# : APERTURE NAME: LPD_UNUSED_13, START ADDRESS: FE400000, END ADDRESS: FE7FFFFF
		# : APERTURE NAME: LPD_UNUSED_13, START ADDRESS: FE400000, END ADDRESS: FE7FFFFF
		# : APERTURE NAME: CORESIGHT, START ADDRESS: FE800000, END ADDRESS: FEFFFFFF
		# : APERTURE NAME: CORESIGHT, START ADDRESS: FE800000, END ADDRESS: FEFFFFFF
		# : APERTURE NAME: CORESIGHT, START ADDRESS: FE800000, END ADDRESS: FEFFFFFF
		# : APERTURE NAME: CORESIGHT, START ADDRESS: FE800000, END ADDRESS: FEFFFFFF
		# : APERTURE NAME: CORESIGHT, START ADDRESS: FE800000, END ADDRESS: FEFFFFFF
		# : APERTURE NAME: CORESIGHT, START ADDRESS: FE800000, END ADDRESS: FEFFFFFF
		# : APERTURE NAME: CORESIGHT, START ADDRESS: FE800000, END ADDRESS: FEFFFFFF
		# : APERTURE NAME: CORESIGHT, START ADDRESS: FE800000, END ADDRESS: FEFFFFFF
		# : APERTURE NAME: QSPI_LINEAR_ADDRESS, START ADDRESS: C0000000, END ADDRESS: DFFFFFFF
		# : XPPU CONTROL
}

set psu_ddr_xmpu0_data {
		# : DDR XMPU0
}

set psu_ddr_xmpu1_data {
		# : DDR XMPU1
}

set psu_ddr_xmpu2_data {
		# : DDR XMPU2
}

set psu_ddr_xmpu3_data {
		# : DDR XMPU3
}

set psu_ddr_xmpu4_data {
		# : DDR XMPU4
}

set psu_ddr_xmpu5_data {
		# : DDR XMPU5
}

set psu_ocm_xmpu_data {
		# : OCM XMPU
}

set psu_fpd_xmpu_data {
		# : FPD XMPU
}

set psu_protection_lock_data {
		# : LOCKING PROTECTION MODULE
		# : XPPU LOCK
		# : APERTURE NAME: LPD_XPPU, START ADDRESS: FF980000, END ADDRESS: FF99FFFF
		# : XMPU LOCK
		# : LOCK OCM XMPU ONLY IF IT IS NOT PROTECTED BY ANY MASTER
		# : LOCK FPD XMPU ONLY IF IT IS NOT PROTECTED BY ANY MASTER
		# : LOCK DDR XMPU ONLY IF IT IS NOT PROTECTED BY ANY MASTER
		# : LOCK DDR XMPU ONLY IF IT IS NOT PROTECTED BY ANY MASTER
		# : LOCK DDR XMPU ONLY IF IT IS NOT PROTECTED BY ANY MASTER
		# : LOCK DDR XMPU ONLY IF IT IS NOT PROTECTED BY ANY MASTER
		# : LOCK DDR XMPU ONLY IF IT IS NOT PROTECTED BY ANY MASTER
		# : LOCK DDR XMPU ONLY IF IT IS NOT PROTECTED BY ANY MASTER
}

set psu_apply_master_tz {
		# : RPU
		# : DP TZ
		# Register : slcr_dpdma @ 0XFD690040</p>

		# TrustZone classification for DisplayPort DMA
		# PSU_FPD_SLCR_SECURE_SLCR_DPDMA_TZ                                               1

		# DPDMA TrustZone Settings
		#(OFFSET, MASK, VALUE)      (0XFD690040, 0x00000001U ,0x00000001U)  */
    mask_write 0XFD690040 0x00000001 0x00000001
		# : SATA TZ
		# : PCIE TZ
		# Register : slcr_pcie @ 0XFD690030</p>

		# TrustZone classification for DMA Channel 0
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_DMA_0                                          1

		# TrustZone classification for DMA Channel 1
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_DMA_1                                          1

		# TrustZone classification for DMA Channel 2
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_DMA_2                                          1

		# TrustZone classification for DMA Channel 3
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_DMA_3                                          1

		# TrustZone classification for Ingress Address Translation 0
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_INGR_0                                      1

		# TrustZone classification for Ingress Address Translation 1
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_INGR_1                                      1

		# TrustZone classification for Ingress Address Translation 2
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_INGR_2                                      1

		# TrustZone classification for Ingress Address Translation 3
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_INGR_3                                      1

		# TrustZone classification for Ingress Address Translation 4
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_INGR_4                                      1

		# TrustZone classification for Ingress Address Translation 5
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_INGR_5                                      1

		# TrustZone classification for Ingress Address Translation 6
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_INGR_6                                      1

		# TrustZone classification for Ingress Address Translation 7
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_INGR_7                                      1

		# TrustZone classification for Egress Address Translation 0
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_EGR_0                                       1

		# TrustZone classification for Egress Address Translation 1
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_EGR_1                                       1

		# TrustZone classification for Egress Address Translation 2
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_EGR_2                                       1

		# TrustZone classification for Egress Address Translation 3
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_EGR_3                                       1

		# TrustZone classification for Egress Address Translation 4
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_EGR_4                                       1

		# TrustZone classification for Egress Address Translation 5
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_EGR_5                                       1

		# TrustZone classification for Egress Address Translation 6
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_EGR_6                                       1

		# TrustZone classification for Egress Address Translation 7
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_AT_EGR_7                                       1

		# TrustZone classification for DMA Registers
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_DMA_REGS                                       1

		# TrustZone classification for MSIx Table
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_MSIX_TABLE                                     1

		# TrustZone classification for MSIx PBA
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_MSIX_PBA                                       1

		# TrustZone classification for ECAM
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_ECAM                                           1

		# TrustZone classification for Bridge Common Registers
		# PSU_FPD_SLCR_SECURE_SLCR_PCIE_TZ_BRIDGE_REGS                                    1

		# PCIe TrustZone settings. This register may only be modified during bootu
    # p (while PCIe block is disabled)
		#(OFFSET, MASK, VALUE)      (0XFD690030, 0x01FFFFFFU ,0x01FFFFFFU)  */
    mask_write 0XFD690030 0x01FFFFFF 0x01FFFFFF
		# : USB TZ
		# Register : slcr_usb @ 0XFF4B0034</p>

		# TrustZone Classification for USB3_0
		# PSU_LPD_SLCR_SECURE_SLCR_USB_TZ_USB3_0                                          1

		# TrustZone Classification for USB3_1
		# PSU_LPD_SLCR_SECURE_SLCR_USB_TZ_USB3_1                                          1

		# USB3 TrustZone settings
		#(OFFSET, MASK, VALUE)      (0XFF4B0034, 0x00000003U ,0x00000003U)  */
    mask_write 0XFF4B0034 0x00000003 0x00000003
		# : SD TZ
		# Register : IOU_AXI_RPRTCN @ 0XFF240004</p>

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_RPRTCN_SD0_AXI_ARPROT                               2

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_RPRTCN_SD1_AXI_ARPROT                               2

		# AXI read protection type selection
		#(OFFSET, MASK, VALUE)      (0XFF240004, 0x003F0000U ,0x00120000U)  */
    mask_write 0XFF240004 0x003F0000 0x00120000
		# Register : IOU_AXI_WPRTCN @ 0XFF240000</p>

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_WPRTCN_SD0_AXI_AWPROT                               2

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_WPRTCN_SD1_AXI_AWPROT                               2

		# AXI write protection type selection
		#(OFFSET, MASK, VALUE)      (0XFF240000, 0x003F0000U ,0x00120000U)  */
    mask_write 0XFF240000 0x003F0000 0x00120000
		# : GEM TZ
		# Register : IOU_AXI_RPRTCN @ 0XFF240004</p>

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_RPRTCN_GEM0_AXI_ARPROT                              2

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_RPRTCN_GEM1_AXI_ARPROT                              2

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_RPRTCN_GEM2_AXI_ARPROT                              2

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_RPRTCN_GEM3_AXI_ARPROT                              2

		# AXI read protection type selection
		#(OFFSET, MASK, VALUE)      (0XFF240004, 0x00000FFFU ,0x00000492U)  */
    mask_write 0XFF240004 0x00000FFF 0x00000492
		# Register : IOU_AXI_WPRTCN @ 0XFF240000</p>

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_WPRTCN_GEM0_AXI_AWPROT                              2

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_WPRTCN_GEM1_AXI_AWPROT                              2

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_WPRTCN_GEM2_AXI_AWPROT                              2

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_WPRTCN_GEM3_AXI_AWPROT                              2

		# AXI write protection type selection
		#(OFFSET, MASK, VALUE)      (0XFF240000, 0x00000FFFU ,0x00000492U)  */
    mask_write 0XFF240000 0x00000FFF 0x00000492
		# : QSPI TZ
		# Register : IOU_AXI_WPRTCN @ 0XFF240000</p>

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_WPRTCN_QSPI_AXI_AWPROT                              2

		# AXI write protection type selection
		#(OFFSET, MASK, VALUE)      (0XFF240000, 0x0E000000U ,0x04000000U)  */
    mask_write 0XFF240000 0x0E000000 0x04000000
		# : NAND TZ
		# Register : IOU_AXI_RPRTCN @ 0XFF240004</p>

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_RPRTCN_NAND_AXI_ARPROT                              2

		# AXI read protection type selection
		#(OFFSET, MASK, VALUE)      (0XFF240004, 0x01C00000U ,0x00800000U)  */
    mask_write 0XFF240004 0x01C00000 0x00800000
		# Register : IOU_AXI_WPRTCN @ 0XFF240000</p>

		# AXI protection [0] = '0' : Normal access [0] = '1' : Previleged access [
    # 1] = '0' : Secure access [1] = '1' : No secure access [2] = '0' : Data a
    # ccess [2] = '1'' : Instruction access
		# PSU_IOU_SECURE_SLCR_IOU_AXI_WPRTCN_NAND_AXI_AWPROT                              2

		# AXI write protection type selection
		#(OFFSET, MASK, VALUE)      (0XFF240000, 0x01C00000U ,0x00800000U)  */
    mask_write 0XFF240000 0x01C00000 0x00800000
		# : DMA TZ
		# Register : slcr_adma @ 0XFF4B0024</p>

		# TrustZone Classification for ADMA
		# PSU_LPD_SLCR_SECURE_SLCR_ADMA_TZ                                                0xFF

		# RPU TrustZone settings
		#(OFFSET, MASK, VALUE)      (0XFF4B0024, 0x000000FFU ,0x000000FFU)  */
    mask_write 0XFF4B0024 0x000000FF 0x000000FF
		# Register : slcr_gdma @ 0XFD690050</p>

		# TrustZone Classification for GDMA
		# PSU_FPD_SLCR_SECURE_SLCR_GDMA_TZ                                                0xFF

		# GDMA Trustzone Settings
		#(OFFSET, MASK, VALUE)      (0XFD690050, 0x000000FFU ,0x000000FFU)  */
    mask_write 0XFD690050 0x000000FF 0x000000FF
}

set psu_serdes_init_data {
		# : SERDES INITIALIZATION
		# : GT REFERENCE CLOCK SOURCE SELECTION
		# Register : PLL_REF_SEL0 @ 0XFD410000</p>

		# PLL0 Reference Selection. 0x0 - 5MHz, 0x1 - 9.6MHz, 0x2 - 10MHz, 0x3 - 1
    # 2MHz, 0x4 - 13MHz, 0x5 - 19.2MHz, 0x6 - 20MHz, 0x7 - 24MHz, 0x8 - 26MHz,
    #  0x9 - 27MHz, 0xA - 38.4MHz, 0xB - 40MHz, 0xC - 52MHz, 0xD - 100MHz, 0xE
    #  - 108MHz, 0xF - 125MHz, 0x10 - 135MHz, 0x11 - 150 MHz. 0x12 to 0x1F - R
    # eserved
		# PSU_SERDES_PLL_REF_SEL0_PLLREFSEL0                                              0xD

		# PLL0 Reference Selection Register
		#(OFFSET, MASK, VALUE)      (0XFD410000, 0x0000001FU ,0x0000000DU)  */
    mask_write 0XFD410000 0x0000001F 0x0000000D
		# : GT REFERENCE CLOCK FREQUENCY SELECTION
		# Register : L0_L0_REF_CLK_SEL @ 0XFD402860</p>

		# Sel of lane 0 ref clock local mux. Set to 1 to select lane 0 slicer outp
    # ut. Set to 0 to select lane0 ref clock mux output.
		# PSU_SERDES_L0_L0_REF_CLK_SEL_L0_REF_CLK_LCL_SEL                                 0x1

		# Lane0 Ref Clock Selection Register
		#(OFFSET, MASK, VALUE)      (0XFD402860, 0x00000080U ,0x00000080U)  */
    mask_write 0XFD402860 0x00000080 0x00000080
		# : ENABLE SPREAD SPECTRUM
		# : ENABLE CHICKEN BIT FOR PCIE AND USB
		# Register : L0_TM_AUX_0 @ 0XFD4010CC</p>

		# Spare- not used
		# PSU_SERDES_L0_TM_AUX_0_BIT_2                                                    1

		# Spare registers
		#(OFFSET, MASK, VALUE)      (0XFD4010CC, 0x00000020U ,0x00000020U)  */
    mask_write 0XFD4010CC 0x00000020 0x00000020
		# : ENABLING EYE SURF
		# Register : L0_TM_DIG_8 @ 0XFD401074</p>

		# Enable Eye Surf
		# PSU_SERDES_L0_TM_DIG_8_EYESURF_ENABLE                                           0x1

		# Test modes for Elastic buffer and enabling Eye Surf
		#(OFFSET, MASK, VALUE)      (0XFD401074, 0x00000010U ,0x00000010U)  */
    mask_write 0XFD401074 0x00000010 0x00000010
		# Register : L1_TM_DIG_8 @ 0XFD405074</p>

		# Enable Eye Surf
		# PSU_SERDES_L1_TM_DIG_8_EYESURF_ENABLE                                           0x1

		# Test modes for Elastic buffer and enabling Eye Surf
		#(OFFSET, MASK, VALUE)      (0XFD405074, 0x00000010U ,0x00000010U)  */
    mask_write 0XFD405074 0x00000010 0x00000010
		# Register : L2_TM_DIG_8 @ 0XFD409074</p>

		# Enable Eye Surf
		# PSU_SERDES_L2_TM_DIG_8_EYESURF_ENABLE                                           0x1

		# Test modes for Elastic buffer and enabling Eye Surf
		#(OFFSET, MASK, VALUE)      (0XFD409074, 0x00000010U ,0x00000010U)  */
    mask_write 0XFD409074 0x00000010 0x00000010
		# Register : L3_TM_DIG_8 @ 0XFD40D074</p>

		# Enable Eye Surf
		# PSU_SERDES_L3_TM_DIG_8_EYESURF_ENABLE                                           0x1

		# Test modes for Elastic buffer and enabling Eye Surf
		#(OFFSET, MASK, VALUE)      (0XFD40D074, 0x00000010U ,0x00000010U)  */
    mask_write 0XFD40D074 0x00000010 0x00000010
		# : ILL SETTINGS FOR GAIN AND LOCK SETTINGS
		# Register : L0_TM_MISC2 @ 0XFD40189C</p>

		# ILL calib counts BYPASSED with calcode bits
		# PSU_SERDES_L0_TM_MISC2_ILL_CAL_BYPASS_COUNTS                                    0x1

		# sampler cal
		#(OFFSET, MASK, VALUE)      (0XFD40189C, 0x00000080U ,0x00000080U)  */
    mask_write 0XFD40189C 0x00000080 0x00000080
		# Register : L0_TM_IQ_ILL1 @ 0XFD4018F8</p>

		# IQ ILL F0 CALCODE bypass value. MPHY : G1a, PCIE : Gen 1, SATA : Gen1 ,
    # USB3 : SS
		# PSU_SERDES_L0_TM_IQ_ILL1_ILL_BYPASS_IQ_CALCODE_F0                               0x64

		# iqpi cal code
		#(OFFSET, MASK, VALUE)      (0XFD4018F8, 0x000000FFU ,0x00000064U)  */
    mask_write 0XFD4018F8 0x000000FF 0x00000064
		# Register : L0_TM_IQ_ILL2 @ 0XFD4018FC</p>

		# IQ ILL F1 CALCODE bypass value. MPHY : G1b, PCIE : Gen2, SATA: Gen2
		# PSU_SERDES_L0_TM_IQ_ILL2_ILL_BYPASS_IQ_CALCODE_F1                               0x64

		# iqpi cal code
		#(OFFSET, MASK, VALUE)      (0XFD4018FC, 0x000000FFU ,0x00000064U)  */
    mask_write 0XFD4018FC 0x000000FF 0x00000064
		# Register : L0_TM_ILL12 @ 0XFD401990</p>

		# G1A pll ctr bypass value
		# PSU_SERDES_L0_TM_ILL12_G1A_PLL_CTR_BYP_VAL                                      0x11

		# ill pll counter values
		#(OFFSET, MASK, VALUE)      (0XFD401990, 0x000000FFU ,0x00000011U)  */
    mask_write 0XFD401990 0x000000FF 0x00000011
		# Register : L0_TM_E_ILL1 @ 0XFD401924</p>

		# E ILL F0 CALCODE bypass value. MPHY : G1a, PCIE : Gen 1, SATA : Gen1 , U
    # SB3 : SS
		# PSU_SERDES_L0_TM_E_ILL1_ILL_BYPASS_E_CALCODE_F0                                 0x4

		# epi cal code
		#(OFFSET, MASK, VALUE)      (0XFD401924, 0x000000FFU ,0x00000004U)  */
    mask_write 0XFD401924 0x000000FF 0x00000004
		# Register : L0_TM_E_ILL2 @ 0XFD401928</p>

		# E ILL F1 CALCODE bypass value. MPHY : G1b, PCIE : Gen2, SATA: Gen2
		# PSU_SERDES_L0_TM_E_ILL2_ILL_BYPASS_E_CALCODE_F1                                 0xFE

		# epi cal code
		#(OFFSET, MASK, VALUE)      (0XFD401928, 0x000000FFU ,0x000000FEU)  */
    mask_write 0XFD401928 0x000000FF 0x000000FE
		# Register : L0_TM_IQ_ILL3 @ 0XFD401900</p>

		# IQ ILL F2CALCODE bypass value. MPHY : G2a, SATA : Gen3
		# PSU_SERDES_L0_TM_IQ_ILL3_ILL_BYPASS_IQ_CALCODE_F2                               0x64

		# iqpi cal code
		#(OFFSET, MASK, VALUE)      (0XFD401900, 0x000000FFU ,0x00000064U)  */
    mask_write 0XFD401900 0x000000FF 0x00000064
		# Register : L0_TM_E_ILL3 @ 0XFD40192C</p>

		# E ILL F2CALCODE bypass value. MPHY : G2a, SATA : Gen3
		# PSU_SERDES_L0_TM_E_ILL3_ILL_BYPASS_E_CALCODE_F2                                 0x0

		# epi cal code
		#(OFFSET, MASK, VALUE)      (0XFD40192C, 0x000000FFU ,0x00000000U)  */
    mask_write 0XFD40192C 0x000000FF 0x00000000
		# Register : L0_TM_ILL8 @ 0XFD401980</p>

		# ILL calibration code change wait time
		# PSU_SERDES_L0_TM_ILL8_ILL_CAL_ITER_WAIT                                         0xFF

		# ILL cal routine control
		#(OFFSET, MASK, VALUE)      (0XFD401980, 0x000000FFU ,0x000000FFU)  */
    mask_write 0XFD401980 0x000000FF 0x000000FF
		# Register : L0_TM_IQ_ILL8 @ 0XFD401914</p>

		# IQ ILL polytrim bypass value
		# PSU_SERDES_L0_TM_IQ_ILL8_ILL_BYPASS_IQ_POLYTRIM_VAL                             0xF7

		# iqpi polytrim
		#(OFFSET, MASK, VALUE)      (0XFD401914, 0x000000FFU ,0x000000F7U)  */
    mask_write 0XFD401914 0x000000FF 0x000000F7
		# Register : L0_TM_IQ_ILL9 @ 0XFD401918</p>

		# bypass IQ polytrim
		# PSU_SERDES_L0_TM_IQ_ILL9_ILL_BYPASS_IQ_POLYTIM                                  0x1

		# enables for lf,constant gm trim and polytirm
		#(OFFSET, MASK, VALUE)      (0XFD401918, 0x00000001U ,0x00000001U)  */
    mask_write 0XFD401918 0x00000001 0x00000001
		# Register : L0_TM_E_ILL8 @ 0XFD401940</p>

		# E ILL polytrim bypass value
		# PSU_SERDES_L0_TM_E_ILL8_ILL_BYPASS_E_POLYTRIM_VAL                               0xF7

		# epi polytrim
		#(OFFSET, MASK, VALUE)      (0XFD401940, 0x000000FFU ,0x000000F7U)  */
    mask_write 0XFD401940 0x000000FF 0x000000F7
		# Register : L0_TM_E_ILL9 @ 0XFD401944</p>

		# bypass E polytrim
		# PSU_SERDES_L0_TM_E_ILL9_ILL_BYPASS_E_POLYTIM                                    0x1

		# enables for lf,constant gm trim and polytirm
		#(OFFSET, MASK, VALUE)      (0XFD401944, 0x00000001U ,0x00000001U)  */
    mask_write 0XFD401944 0x00000001 0x00000001
		# Register : L0_TM_ILL13 @ 0XFD401994</p>

		# ILL cal idle val refcnt
		# PSU_SERDES_L0_TM_ILL13_ILL_CAL_IDLE_VAL_REFCNT                                  0x7

		# ill cal idle value count
		#(OFFSET, MASK, VALUE)      (0XFD401994, 0x00000007U ,0x00000007U)  */
    mask_write 0XFD401994 0x00000007 0x00000007
		# Register : L1_TM_ILL13 @ 0XFD405994</p>

		# ILL cal idle val refcnt
		# PSU_SERDES_L1_TM_ILL13_ILL_CAL_IDLE_VAL_REFCNT                                  0x7

		# ill cal idle value count
		#(OFFSET, MASK, VALUE)      (0XFD405994, 0x00000007U ,0x00000007U)  */
    mask_write 0XFD405994 0x00000007 0x00000007
		# Register : L2_TM_ILL13 @ 0XFD409994</p>

		# ILL cal idle val refcnt
		# PSU_SERDES_L2_TM_ILL13_ILL_CAL_IDLE_VAL_REFCNT                                  0x7

		# ill cal idle value count
		#(OFFSET, MASK, VALUE)      (0XFD409994, 0x00000007U ,0x00000007U)  */
    mask_write 0XFD409994 0x00000007 0x00000007
		# Register : L3_TM_ILL13 @ 0XFD40D994</p>

		# ILL cal idle val refcnt
		# PSU_SERDES_L3_TM_ILL13_ILL_CAL_IDLE_VAL_REFCNT                                  0x7

		# ill cal idle value count
		#(OFFSET, MASK, VALUE)      (0XFD40D994, 0x00000007U ,0x00000007U)  */
    mask_write 0XFD40D994 0x00000007 0x00000007
		# : SYMBOL LOCK AND WAIT
		# Register : L0_TM_DIG_10 @ 0XFD40107C</p>

		# CDR lock wait time. (1-16 us). cdr_lock_wait_time = 4'b xxxx + 4'b 0001
		# PSU_SERDES_L0_TM_DIG_10_CDR_BIT_LOCK_TIME                                       0x1

		# test control for changing cdr lock wait time
		#(OFFSET, MASK, VALUE)      (0XFD40107C, 0x0000000FU ,0x00000001U)  */
    mask_write 0XFD40107C 0x0000000F 0x00000001
		# Register : L1_TM_DIG_10 @ 0XFD40507C</p>

		# CDR lock wait time. (1-16 us). cdr_lock_wait_time = 4'b xxxx + 4'b 0001
		# PSU_SERDES_L1_TM_DIG_10_CDR_BIT_LOCK_TIME                                       0x1

		# test control for changing cdr lock wait time
		#(OFFSET, MASK, VALUE)      (0XFD40507C, 0x0000000FU ,0x00000001U)  */
    mask_write 0XFD40507C 0x0000000F 0x00000001
		# Register : L2_TM_DIG_10 @ 0XFD40907C</p>

		# CDR lock wait time. (1-16 us). cdr_lock_wait_time = 4'b xxxx + 4'b 0001
		# PSU_SERDES_L2_TM_DIG_10_CDR_BIT_LOCK_TIME                                       0x1

		# test control for changing cdr lock wait time
		#(OFFSET, MASK, VALUE)      (0XFD40907C, 0x0000000FU ,0x00000001U)  */
    mask_write 0XFD40907C 0x0000000F 0x00000001
		# Register : L3_TM_DIG_10 @ 0XFD40D07C</p>

		# CDR lock wait time. (1-16 us). cdr_lock_wait_time = 4'b xxxx + 4'b 0001
		# PSU_SERDES_L3_TM_DIG_10_CDR_BIT_LOCK_TIME                                       0x1

		# test control for changing cdr lock wait time
		#(OFFSET, MASK, VALUE)      (0XFD40D07C, 0x0000000FU ,0x00000001U)  */
    mask_write 0XFD40D07C 0x0000000F 0x00000001
		# : SIOU SETTINGS FOR BYPASS CONTROL,HSRX-DIG
		# Register : L0_TM_RST_DLY @ 0XFD4019A4</p>

		# Delay apb reset by specified amount
		# PSU_SERDES_L0_TM_RST_DLY_APB_RST_DLY                                            0xFF

		# reset delay for apb reset w.r.t pso of hsrx
		#(OFFSET, MASK, VALUE)      (0XFD4019A4, 0x000000FFU ,0x000000FFU)  */
    mask_write 0XFD4019A4 0x000000FF 0x000000FF
		# Register : L0_TM_ANA_BYP_15 @ 0XFD401038</p>

		# Enable Bypass for <7> of TM_ANA_BYPS_15
		# PSU_SERDES_L0_TM_ANA_BYP_15_FORCE_UPHY_ENABLE_LOW_LEAKAGE                       0x1

		# Bypass control for pcs-pma interface. EQ supplies, main master supply an
    # d ps for samp c2c
		#(OFFSET, MASK, VALUE)      (0XFD401038, 0x00000040U ,0x00000040U)  */
    mask_write 0XFD401038 0x00000040 0x00000040
		# Register : L0_TM_ANA_BYP_12 @ 0XFD40102C</p>

		# Enable Bypass for <7> of TM_ANA_BYPS_12
		# PSU_SERDES_L0_TM_ANA_BYP_12_FORCE_UPHY_PSO_HSRXDIG                              0x1

		# Bypass control for pcs-pma interface. Hsrx supply, hsrx des, and cdr ena
    # ble controls
		#(OFFSET, MASK, VALUE)      (0XFD40102C, 0x00000040U ,0x00000040U)  */
    mask_write 0XFD40102C 0x00000040 0x00000040
		# Register : L1_TM_RST_DLY @ 0XFD4059A4</p>

		# Delay apb reset by specified amount
		# PSU_SERDES_L1_TM_RST_DLY_APB_RST_DLY                                            0xFF

		# reset delay for apb reset w.r.t pso of hsrx
		#(OFFSET, MASK, VALUE)      (0XFD4059A4, 0x000000FFU ,0x000000FFU)  */
    mask_write 0XFD4059A4 0x000000FF 0x000000FF
		# Register : L1_TM_ANA_BYP_15 @ 0XFD405038</p>

		# Enable Bypass for <7> of TM_ANA_BYPS_15
		# PSU_SERDES_L1_TM_ANA_BYP_15_FORCE_UPHY_ENABLE_LOW_LEAKAGE                       0x1

		# Bypass control for pcs-pma interface. EQ supplies, main master supply an
    # d ps for samp c2c
		#(OFFSET, MASK, VALUE)      (0XFD405038, 0x00000040U ,0x00000040U)  */
    mask_write 0XFD405038 0x00000040 0x00000040
		# Register : L1_TM_ANA_BYP_12 @ 0XFD40502C</p>

		# Enable Bypass for <7> of TM_ANA_BYPS_12
		# PSU_SERDES_L1_TM_ANA_BYP_12_FORCE_UPHY_PSO_HSRXDIG                              0x1

		# Bypass control for pcs-pma interface. Hsrx supply, hsrx des, and cdr ena
    # ble controls
		#(OFFSET, MASK, VALUE)      (0XFD40502C, 0x00000040U ,0x00000040U)  */
    mask_write 0XFD40502C 0x00000040 0x00000040
		# Register : L2_TM_RST_DLY @ 0XFD4099A4</p>

		# Delay apb reset by specified amount
		# PSU_SERDES_L2_TM_RST_DLY_APB_RST_DLY                                            0xFF

		# reset delay for apb reset w.r.t pso of hsrx
		#(OFFSET, MASK, VALUE)      (0XFD4099A4, 0x000000FFU ,0x000000FFU)  */
    mask_write 0XFD4099A4 0x000000FF 0x000000FF
		# Register : L2_TM_ANA_BYP_15 @ 0XFD409038</p>

		# Enable Bypass for <7> of TM_ANA_BYPS_15
		# PSU_SERDES_L2_TM_ANA_BYP_15_FORCE_UPHY_ENABLE_LOW_LEAKAGE                       0x1

		# Bypass control for pcs-pma interface. EQ supplies, main master supply an
    # d ps for samp c2c
		#(OFFSET, MASK, VALUE)      (0XFD409038, 0x00000040U ,0x00000040U)  */
    mask_write 0XFD409038 0x00000040 0x00000040
		# Register : L2_TM_ANA_BYP_12 @ 0XFD40902C</p>

		# Enable Bypass for <7> of TM_ANA_BYPS_12
		# PSU_SERDES_L2_TM_ANA_BYP_12_FORCE_UPHY_PSO_HSRXDIG                              0x1

		# Bypass control for pcs-pma interface. Hsrx supply, hsrx des, and cdr ena
    # ble controls
		#(OFFSET, MASK, VALUE)      (0XFD40902C, 0x00000040U ,0x00000040U)  */
    mask_write 0XFD40902C 0x00000040 0x00000040
		# Register : L3_TM_RST_DLY @ 0XFD40D9A4</p>

		# Delay apb reset by specified amount
		# PSU_SERDES_L3_TM_RST_DLY_APB_RST_DLY                                            0xFF

		# reset delay for apb reset w.r.t pso of hsrx
		#(OFFSET, MASK, VALUE)      (0XFD40D9A4, 0x000000FFU ,0x000000FFU)  */
    mask_write 0XFD40D9A4 0x000000FF 0x000000FF
		# Register : L3_TM_ANA_BYP_15 @ 0XFD40D038</p>

		# Enable Bypass for <7> of TM_ANA_BYPS_15
		# PSU_SERDES_L3_TM_ANA_BYP_15_FORCE_UPHY_ENABLE_LOW_LEAKAGE                       0x1

		# Bypass control for pcs-pma interface. EQ supplies, main master supply an
    # d ps for samp c2c
		#(OFFSET, MASK, VALUE)      (0XFD40D038, 0x00000040U ,0x00000040U)  */
    mask_write 0XFD40D038 0x00000040 0x00000040
		# Register : L3_TM_ANA_BYP_12 @ 0XFD40D02C</p>

		# Enable Bypass for <7> of TM_ANA_BYPS_12
		# PSU_SERDES_L3_TM_ANA_BYP_12_FORCE_UPHY_PSO_HSRXDIG                              0x1

		# Bypass control for pcs-pma interface. Hsrx supply, hsrx des, and cdr ena
    # ble controls
		#(OFFSET, MASK, VALUE)      (0XFD40D02C, 0x00000040U ,0x00000040U)  */
    mask_write 0XFD40D02C 0x00000040 0x00000040
		# : DISABLE FPL/FFL
		# Register : L0_TM_MISC3 @ 0XFD4019AC</p>

		# CDR fast phase lock control
		# PSU_SERDES_L0_TM_MISC3_CDR_EN_FPL                                               0x0

		# CDR fast frequency lock control
		# PSU_SERDES_L0_TM_MISC3_CDR_EN_FFL                                               0x0

		# debug bus selection bit, cdr fast phase and freq controls
		#(OFFSET, MASK, VALUE)      (0XFD4019AC, 0x00000003U ,0x00000000U)  */
    mask_write 0XFD4019AC 0x00000003 0x00000000
		# Register : L1_TM_MISC3 @ 0XFD4059AC</p>

		# CDR fast phase lock control
		# PSU_SERDES_L1_TM_MISC3_CDR_EN_FPL                                               0x0

		# CDR fast frequency lock control
		# PSU_SERDES_L1_TM_MISC3_CDR_EN_FFL                                               0x0

		# debug bus selection bit, cdr fast phase and freq controls
		#(OFFSET, MASK, VALUE)      (0XFD4059AC, 0x00000003U ,0x00000000U)  */
    mask_write 0XFD4059AC 0x00000003 0x00000000
		# Register : L2_TM_MISC3 @ 0XFD4099AC</p>

		# CDR fast phase lock control
		# PSU_SERDES_L2_TM_MISC3_CDR_EN_FPL                                               0x0

		# CDR fast frequency lock control
		# PSU_SERDES_L2_TM_MISC3_CDR_EN_FFL                                               0x0

		# debug bus selection bit, cdr fast phase and freq controls
		#(OFFSET, MASK, VALUE)      (0XFD4099AC, 0x00000003U ,0x00000000U)  */
    mask_write 0XFD4099AC 0x00000003 0x00000000
		# Register : L3_TM_MISC3 @ 0XFD40D9AC</p>

		# CDR fast phase lock control
		# PSU_SERDES_L3_TM_MISC3_CDR_EN_FPL                                               0x0

		# CDR fast frequency lock control
		# PSU_SERDES_L3_TM_MISC3_CDR_EN_FFL                                               0x0

		# debug bus selection bit, cdr fast phase and freq controls
		#(OFFSET, MASK, VALUE)      (0XFD40D9AC, 0x00000003U ,0x00000000U)  */
    mask_write 0XFD40D9AC 0x00000003 0x00000000
		# : DISABLE DYNAMIC OFFSET CALIBRATION
		# Register : L0_TM_EQ11 @ 0XFD401978</p>

		# Force EQ offset correction algo off if not forced on
		# PSU_SERDES_L0_TM_EQ11_FORCE_EQ_OFFS_OFF                                         0x1

		# eq dynamic offset correction
		#(OFFSET, MASK, VALUE)      (0XFD401978, 0x00000010U ,0x00000010U)  */
    mask_write 0XFD401978 0x00000010 0x00000010
		# Register : L1_TM_EQ11 @ 0XFD405978</p>

		# Force EQ offset correction algo off if not forced on
		# PSU_SERDES_L1_TM_EQ11_FORCE_EQ_OFFS_OFF                                         0x1

		# eq dynamic offset correction
		#(OFFSET, MASK, VALUE)      (0XFD405978, 0x00000010U ,0x00000010U)  */
    mask_write 0XFD405978 0x00000010 0x00000010
		# Register : L2_TM_EQ11 @ 0XFD409978</p>

		# Force EQ offset correction algo off if not forced on
		# PSU_SERDES_L2_TM_EQ11_FORCE_EQ_OFFS_OFF                                         0x1

		# eq dynamic offset correction
		#(OFFSET, MASK, VALUE)      (0XFD409978, 0x00000010U ,0x00000010U)  */
    mask_write 0XFD409978 0x00000010 0x00000010
		# Register : L3_TM_EQ11 @ 0XFD40D978</p>

		# Force EQ offset correction algo off if not forced on
		# PSU_SERDES_L3_TM_EQ11_FORCE_EQ_OFFS_OFF                                         0x1

		# eq dynamic offset correction
		#(OFFSET, MASK, VALUE)      (0XFD40D978, 0x00000010U ,0x00000010U)  */
    mask_write 0XFD40D978 0x00000010 0x00000010
		# : SERDES ILL CALIB
		# : DISABLE ECO FOR PCIE
		# Register : eco_0 @ 0XFD3D001C</p>

		# For future use
		# PSU_SIOU_ECO_0_FIELD                                                            0x1

		# ECO Register for future use
		#(OFFSET, MASK, VALUE)      (0XFD3D001C, 0xFFFFFFFFU ,0x00000001U)  */
    mask_write 0XFD3D001C 0xFFFFFFFF 0x00000001
		# Register : ECO_0 @ 0XFD480314</p>

		# Reserved for future use
		# PSU_PCIE_ATTRIB_ECO_0_ECO_0                                                     0x4

		# ECO Register 0
		#(OFFSET, MASK, VALUE)      (0XFD480314, 0xFFFFFFFFU ,0x00000004U)  */
    mask_write 0XFD480314 0xFFFFFFFF 0x00000004
		# : GT LANE SETTINGS
		# Register : ICM_CFG0 @ 0XFD410010</p>

		# Controls UPHY Lane 0 protocol configuration. 0 - PowerDown, 1 - PCIe .0,
    #  2 - Sata0, 3 - USB0, 4 - DP.1, 5 - SGMII0, 6 - Unused, 7 - Unused
		# PSU_SERDES_ICM_CFG0_L0_ICM_CFG                                                  1

		# ICM Configuration Register 0
		#(OFFSET, MASK, VALUE)      (0XFD410010, 0x00000007U ,0x00000001U)  */
    mask_write 0XFD410010 0x00000007 0x00000001
		# : CHECKING PLL LOCK
		# : ENABLE SERIAL DATA MUX DEEMPH
		# : CDR AND RX EQUALIZATION SETTINGS
		# : GEM SERDES SETTINGS
		# : ENABLE PRE EMPHAIS AND VOLTAGE SWING
}

set psu_resetout_init_data {
		# : TAKING SERDES PERIPHERAL OUT OF RESET RESET
		# : PUTTING USB0 IN RESET
		# Register : RST_LPD_TOP @ 0XFF5E023C</p>

		# USB 0 reset for control registers
		# PSU_CRL_APB_RST_LPD_TOP_USB0_APB_RESET                                          0X0

		# Software control register for the LPD block.
		#(OFFSET, MASK, VALUE)      (0XFF5E023C, 0x00000400U ,0x00000000U)  */
    mask_write 0XFF5E023C 0x00000400 0x00000000
		# : USB0 PIPE POWER PRESENT
		# Register : fpd_power_prsnt @ 0XFF9D0080</p>

		# This bit is used to choose between PIPE power present and 1'b1
		# PSU_USB3_0_FPD_POWER_PRSNT_OPTION                                               0X1

		# fpd_power_prsnt
		#(OFFSET, MASK, VALUE)      (0XFF9D0080, 0x00000001U ,0x00000001U)  */
    mask_write 0XFF9D0080 0x00000001 0x00000001
		# Register : fpd_pipe_clk @ 0XFF9D007C</p>

		# This bit is used to choose between PIPE clock coming from SerDes and the
    #  suspend clk
		# PSU_USB3_0_FPD_PIPE_CLK_OPTION                                                  0x1

		# fpd_pipe_clk
		#(OFFSET, MASK, VALUE)      (0XFF9D007C, 0x00000001U ,0x00000001U)  */
    mask_write 0XFF9D007C 0x00000001 0x00000001
		# : HIBERREST
		# Register : RST_LPD_TOP @ 0XFF5E023C</p>

		# USB 0 sleep circuit reset
		# PSU_CRL_APB_RST_LPD_TOP_USB0_HIBERRESET                                         0X0

		# USB 0 reset
		# PSU_CRL_APB_RST_LPD_TOP_USB0_CORERESET                                          0X0

		# Software control register for the LPD block.
		#(OFFSET, MASK, VALUE)      (0XFF5E023C, 0x00000140U ,0x00000000U)  */
    mask_write 0XFF5E023C 0x00000140 0x00000000
		# : PUTTING PCIE CFG AND BRIDGE IN RESET
		# Register : RST_FPD_TOP @ 0XFD1A0100</p>

		# PCIE config reset
		# PSU_CRF_APB_RST_FPD_TOP_PCIE_CFG_RESET                                          0X0

		# PCIE bridge block level reset (AXI interface)
		# PSU_CRF_APB_RST_FPD_TOP_PCIE_BRIDGE_RESET                                       0X0

		# FPD Block level software controlled reset
		#(OFFSET, MASK, VALUE)      (0XFD1A0100, 0x000C0000U ,0x00000000U)  */
    mask_write 0XFD1A0100 0x000C0000 0x00000000
		# : USB0 GFLADJ
		# Register : GUSB2PHYCFG @ 0XFE20C200</p>

		# USB 2.0 Turnaround Time (USBTrdTim) Sets the turnaround time in PHY cloc
    # ks. Specifies the response time for a MAC request to the Packet FIFO Con
    # troller (PFC) to fetch data from the DFIFO (SPRAM). The following are th
    # e required values for the minimum SoC bus frequency of 60 MHz. USB turna
    # round time is a critical certification criteria when using long cables a
    # nd five hub levels. The required values for this field: - 4'h5: When the
    #  MAC interface is 16-bit UTMI+. - 4'h9: When the MAC interface is 8-bit
    # UTMI+/ULPI. If SoC bus clock is less than 60 MHz, and USB turnaround tim
    # e is not critical, this field can be set to a larger value. Note: This f
    # ield is valid only in device mode.
		# PSU_USB3_0_XHCI_GUSB2PHYCFG_USBTRDTIM                                           0x9

		# Transceiver Delay: Enables a delay between the assertion of the UTMI/ULP
    # I Transceiver Select signal (for HS) and the assertion of the TxValid si
    # gnal during a HS Chirp. When this bit is set to 1, a delay (of approxima
    # tely 2.5 us) is introduced from the time when the Transceiver Select is
    # set to 2'b00 (HS) to the time the TxValid is driven to 0 for sending the
    #  chirp-K. This delay is required for some UTMI/ULPI PHYs. Note: - If you
    #  enable the hibernation feature when the device core comes out of power-
    # off, you must re-initialize this bit with the appropriate value because
    # the core does not save and restore this bit value during hibernation. -
    # This bit is valid only in device mode.
		# PSU_USB3_0_XHCI_GUSB2PHYCFG_XCVRDLY                                             0x0

		# Enable utmi_sleep_n and utmi_l1_suspend_n (EnblSlpM) The application use
    # s this bit to control utmi_sleep_n and utmi_l1_suspend_n assertion to th
    # e PHY in the L1 state. - 1'b0: utmi_sleep_n and utmi_l1_suspend_n assert
    # ion from the core is not transferred to the external PHY. - 1'b1: utmi_s
    # leep_n and utmi_l1_suspend_n assertion from the core is transferred to t
    # he external PHY. Note: This bit must be set high for Port0 if PHY is use
    # d. Note: In Device mode - Before issuing any device endpoint command whe
    # n operating in 2.0 speeds, disable this bit and enable it after the comm
    # and completes. Without disabling this bit, if a command is issued when t
    # he device is in L1 state and if mac2_clk (utmi_clk/ulpi_clk) is gated of
    # f, the command will not get completed.
		# PSU_USB3_0_XHCI_GUSB2PHYCFG_ENBLSLPM                                            0x0

		# USB 2.0 High-Speed PHY or USB 1.1 Full-Speed Serial Transceiver Select T
    # he application uses this bit to select a high-speed PHY or a full-speed
    # transceiver. - 1'b0: USB 2.0 high-speed UTMI+ or ULPI PHY. This bit is a
    # lways 0, with Write Only access. - 1'b1: USB 1.1 full-speed serial trans
    # ceiver. This bit is always 1, with Write Only access. If both interface
    # types are selected in coreConsultant (that is, parameters' values are no
    # t zero), the application uses this bit to select the active interface is
    #  active, with Read-Write bit access. Note: USB 1.1 full-serial transceiv
    # er is not supported. This bit always reads as 1'b0.
		# PSU_USB3_0_XHCI_GUSB2PHYCFG_PHYSEL                                              0x0

		# Suspend USB2.0 HS/FS/LS PHY (SusPHY) When set, USB2.0 PHY enters Suspend
    #  mode if Suspend conditions are valid. For DRD/OTG configurations, it is
    #  recommended that this bit is set to 0 during coreConsultant configurati
    # on. If it is set to 1, then the application must clear this bit after po
    # wer-on reset. Application needs to set it to 1 after the core initializa
    # tion completes. For all other configurations, this bit can be set to 1 d
    # uring core configuration. Note: - In host mode, on reset, this bit is se
    # t to 1. Software can override this bit after reset. - In device mode, be
    # fore issuing any device endpoint command when operating in 2.0 speeds, d
    # isable this bit and enable it after the command completes. If you issue
    # a command without disabling this bit when the device is in L2 state and
    # if mac2_clk (utmi_clk/ulpi_clk) is gated off, the command will not get c
    # ompleted.
		# PSU_USB3_0_XHCI_GUSB2PHYCFG_SUSPENDUSB20                                        0x1

		# Full-Speed Serial Interface Select (FSIntf) The application uses this bi
    # t to select a unidirectional or bidirectional USB 1.1 full-speed serial
    # transceiver interface. - 1'b0: 6-pin unidirectional full-speed serial in
    # terface. This bit is set to 0 with Read Only access. - 1'b1: 3-pin bidir
    # ectional full-speed serial interface. This bit is set to 0 with Read Onl
    # y access. Note: USB 1.1 full-speed serial interface is not supported. Th
    # is bit always reads as 1'b0.
		# PSU_USB3_0_XHCI_GUSB2PHYCFG_FSINTF                                              0x0

		# ULPI or UTMI+ Select (ULPI_UTMI_Sel) The application uses this bit to se
    # lect a UTMI+ or ULPI Interface. - 1'b0: UTMI+ Interface - 1'b1: ULPI Int
    # erface This bit is writable only if UTMI+ and ULPI is specified for High
    # -Speed PHY Interface(s) in coreConsultant configuration (DWC_USB3_HSPHY_
    # INTERFACE = 3). Otherwise, this bit is read-only and the value depends o
    # n the interface selected through DWC_USB3_HSPHY_INTERFACE.
		# PSU_USB3_0_XHCI_GUSB2PHYCFG_ULPI_UTMI_SEL                                       0x1

		# PHY Interface (PHYIf) If UTMI+ is selected, the application uses this bi
    # t to configure the core to support a UTMI+ PHY with an 8- or 16-bit inte
    # rface. - 1'b0: 8 bits - 1'b1: 16 bits ULPI Mode: 1'b0 Note: - All the en
    # abled 2.0 ports must have the same clock frequency as Port0 clock freque
    # ncy (utmi_clk[0]). - The UTMI 8-bit and 16-bit modes cannot be used toge
    # ther for different ports at the same time (that is, all the ports must b
    # e in 8-bit mode, or all of them must be in 16-bit mode, at a time). - If
    #  any of the USB 2.0 ports is selected as ULPI port for operation, then a
    # ll the USB 2.0 ports must be operating at 60 MHz.
		# PSU_USB3_0_XHCI_GUSB2PHYCFG_PHYIF                                               0x0

		# HS/FS Timeout Calibration (TOutCal) The number of PHY clocks, as indicat
    # ed by the application in this field, is multiplied by a bit-time factor;
    #  this factor is added to the high-speed/full-speed interpacket timeout d
    # uration in the core to account for additional delays introduced by the P
    # HY. This may be required, since the delay introduced by the PHY in gener
    # ating the linestate condition may vary among PHYs. The USB standard time
    # out value for high-speed operation is 736 to 816 (inclusive) bit times.
    # The USB standard timeout value for full-speed operation is 16 to 18 (inc
    # lusive) bit times. The application must program this field based on the
    # speed of connection. The number of bit times added per PHY clock are: Hi
    # gh-speed operation: - One 30-MHz PHY clock = 16 bit times - One 60-MHz P
    # HY clock = 8 bit times Full-speed operation: - One 30-MHz PHY clock = 0.
    # 4 bit times - One 60-MHz PHY clock = 0.2 bit times - One 48-MHz PHY cloc
    # k = 0.25 bit times
		# PSU_USB3_0_XHCI_GUSB2PHYCFG_TOUTCAL                                             0x7

		# ULPI External VBUS Drive (ULPIExtVbusDrv) Selects supply source to drive
    #  5V on VBUS, in the ULPI PHY. - 1'b0: PHY drives VBUS with internal char
    # ge pump (default). - 1'b1: PHY drives VBUS with an external supply. (Onl
    # y when RTL parameter DWC_USB3_HSPHY_INTERFACE = 2 or 3)
		# PSU_USB3_0_XHCI_GUSB2PHYCFG_ULPIEXTVBUSDRV                                      0x1

		# Global USB2 PHY Configuration Register The application must program this
    #  register before starting any transactions on either the SoC bus or the
    # USB. In Device-only configurations, only one register is needed. In Host
    #  mode, per-port registers are implemented.
		#(OFFSET, MASK, VALUE)      (0XFE20C200, 0x00023FFFU ,0x00022457U)  */
    mask_write 0XFE20C200 0x00023FFF 0x00022457
		# Register : GFLADJ @ 0XFE20C630</p>

		# This field indicates the frame length adjustment to be applied when SOF/
    # ITP counter is running on the ref_clk. This register value is used to ad
    # just the ITP interval when GCTL[SOFITPSYNC] is set to '1'; SOF and ITP i
    # nterval when GLADJ.GFLADJ_REFCLK_LPM_SEL is set to '1'. This field must
    # be programmed to a non-zero value only if GFLADJ_REFCLK_LPM_SEL is set t
    # o '1' or GCTL.SOFITPSYNC is set to '1'. The value is derived as follows:
    #  FLADJ_REF_CLK_FLADJ=((125000/ref_clk_period_integer)-(125000/ref_clk_pe
    # riod)) * ref_clk_period where - the ref_clk_period_integer is the intege
    # r value of the ref_clk period got by truncating the decimal (fractional)
    #  value that is programmed in the GUCTL.REF_CLK_PERIOD field. - the ref_c
    # lk_period is the ref_clk period including the fractional value. Examples
    # : If the ref_clk is 24 MHz then - GUCTL.REF_CLK_PERIOD = 41 - GFLADJ.GLA
    # DJ_REFCLK_FLADJ = ((125000/41)-(125000/41.6666))*41.6666 = 2032 (ignorin
    # g the fractional value) If the ref_clk is 48 MHz then - GUCTL.REF_CLK_PE
    # RIOD = 20 - GFLADJ.GLADJ_REFCLK_FLADJ = ((125000/20)-(125000/20.8333))*2
    # 0.8333 = 5208 (ignoring the fractional value)
		# PSU_USB3_0_XHCI_GFLADJ_GFLADJ_REFCLK_FLADJ                                      0x0

		# Global Frame Length Adjustment Register This register provides options f
    # or the software to control the core behavior with respect to SOF (Start
    # of Frame) and ITP (Isochronous Timestamp Packet) timers and frame timer
    # functionality. It provides an option to override the fladj_30mhz_reg sid
    # eband signal. In addition, it enables running SOF or ITP frame timer cou
    # nters completely from the ref_clk. This facilitates hardware LPM in host
    #  mode with the SOF or ITP counters being run from the ref_clk signal.
		#(OFFSET, MASK, VALUE)      (0XFE20C630, 0x003FFF00U ,0x00000000U)  */
    mask_write 0XFE20C630 0x003FFF00 0x00000000
		# Register : GUCTL1 @ 0XFE20C11C</p>

		# When this bit is set to '0', termsel, xcvrsel will become 0 during end o
    # f resume while the opmode will become 0 once controller completes end of
    #  resume and enters U0 state (2 separate commandswill be issued). When th
    # is bit is set to '1', all the termsel, xcvrsel, opmode becomes 0 during
    # end of resume itself (only 1 command will be issued)
		# PSU_USB3_0_XHCI_GUCTL1_RESUME_TERMSEL_XCVRSEL_UNIFY                             0x1

		# Global User Control Register 1
		#(OFFSET, MASK, VALUE)      (0XFE20C11C, 0x00000400U ,0x00000400U)  */
    mask_write 0XFE20C11C 0x00000400 0x00000400
		# Register : GUCTL @ 0XFE20C12C</p>

		# Host IN Auto Retry (USBHstInAutoRetryEn) When set, this field enables th
    # e Auto Retry feature. For IN transfers (non-isochronous) that encounter
    # data packets with CRC errors or internal overrun scenarios, the auto ret
    # ry feature causes the Host core to reply to the device with a non-termin
    # ating retry ACK (that is, an ACK transaction packet with Retry = 1 and N
    # umP != 0). If the Auto Retry feature is disabled (default), the core wil
    # l respond with a terminating retry ACK (that is, an ACK transaction pack
    # et with Retry = 1 and NumP = 0). - 1'b0: Auto Retry Disabled - 1'b1: Aut
    # o Retry Enabled Note: This bit is also applicable to the device mode.
		# PSU_USB3_0_XHCI_GUCTL_USBHSTINAUTORETRYEN                                       0x1

		# Global User Control Register: This register provides a few options for t
    # he software to control the core behavior in the Host mode. Most of the o
    # ptions are used to improve host inter-operability with different devices
    # .
		#(OFFSET, MASK, VALUE)      (0XFE20C12C, 0x00004000U ,0x00004000U)  */
    mask_write 0XFE20C12C 0x00004000 0x00004000
		# : UPDATING TWO PCIE REGISTERS DEFAULT VALUES, AS THESE REGISTERS HAVE INCORRECT RESET VALUES IN SILICON.
		# Register : ATTR_25 @ 0XFD480064</p>

		# If TRUE Completion Timeout Disable is supported. This is required to be
    # TRUE for Endpoint and either setting allowed for Root ports. Drives Devi
    # ce Capability 2 [4]; EP=0x0001; RP=0x0001
		# PSU_PCIE_ATTRIB_ATTR_25_ATTR_CPL_TIMEOUT_DISABLE_SUPPORTED                      0X1

		# ATTR_25
		#(OFFSET, MASK, VALUE)      (0XFD480064, 0x00000200U ,0x00000200U)  */
    mask_write 0XFD480064 0x00000200 0x00000200
		# : PCIE SETTINGS
		# Register : ATTR_7 @ 0XFD48001C</p>

		# Specifies mask/settings for Base Address Register (BAR) 0. If BAR is not
    #  to be implemented, set to 32'h00000000. Bits are defined as follows: Me
    # mory Space BAR [0] = Mem Space Indicator (set to 0) [2:1] = Type field (
    # 10 for 64-bit, 00 for 32-bit) [3] = Prefetchable (0 or 1) [31:4] = Mask
    # for writable bits of BAR; if 32-bit BAR, set uppermost 31:n bits to 1, w
    # here 2^n=memory aperture size in bytes. If 64-bit BAR, set uppermost 63:
    # n bits of \'7bBAR1,BAR0\'7d to 1. IO Space BAR 0] = IO Space Indicator (
    # set to 1) [1] = Reserved (set to 0) [31:2] = Mask for writable bits of B
    # AR; set uppermost 31:n bits to 1, where 2^n=i/o aperture size in bytes.;
    #  EP=0x0004; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_7_ATTR_BAR0                                                0x0

		# ATTR_7
		#(OFFSET, MASK, VALUE)      (0XFD48001C, 0x0000FFFFU ,0x00000000U)  */
    mask_write 0XFD48001C 0x0000FFFF 0x00000000
		# Register : ATTR_8 @ 0XFD480020</p>

		# Specifies mask/settings for Base Address Register (BAR) 0. If BAR is not
    #  to be implemented, set to 32'h00000000. Bits are defined as follows: Me
    # mory Space BAR [0] = Mem Space Indicator (set to 0) [2:1] = Type field (
    # 10 for 64-bit, 00 for 32-bit) [3] = Prefetchable (0 or 1) [31:4] = Mask
    # for writable bits of BAR; if 32-bit BAR, set uppermost 31:n bits to 1, w
    # here 2^n=memory aperture size in bytes. If 64-bit BAR, set uppermost 63:
    # n bits of \'7bBAR1,BAR0\'7d to 1. IO Space BAR 0] = IO Space Indicator (
    # set to 1) [1] = Reserved (set to 0) [31:2] = Mask for writable bits of B
    # AR; set uppermost 31:n bits to 1, where 2^n=i/o aperture size in bytes.;
    #  EP=0xFFF0; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_8_ATTR_BAR0                                                0xfff0

		# ATTR_8
		#(OFFSET, MASK, VALUE)      (0XFD480020, 0x0000FFFFU ,0x0000FFF0U)  */
    mask_write 0XFD480020 0x0000FFFF 0x0000FFF0
		# Register : ATTR_9 @ 0XFD480024</p>

		# Specifies mask/settings for Base Address Register (BAR) 1 if BAR0 is a 3
    # 2-bit BAR, or the upper bits of \'7bBAR1,BAR0\'7d if BAR0 is a 64-bit BA
    # R. If BAR is not to be implemented, set to 32'h00000000. See BAR0 descri
    # ption if this functions as the upper bits of a 64-bit BAR. Bits are defi
    # ned as follows: Memory Space BAR (not upper bits of BAR0) [0] = Mem Spac
    # e Indicator (set to 0) [2:1] = Type field (10 for 64-bit, 00 for 32-bit)
    #  [3] = Prefetchable (0 or 1) [31:4] = Mask for writable bits of BAR; if
    # 32-bit BAR, set uppermost 31:n bits to 1, where 2^n=memory aperture size
    #  in bytes. If 64-bit BAR, set uppermost 63:n bits of \'7bBAR2,BAR1\'7d t
    # o 1. IO Space BAR 0] = IO Space Indicator (set to 1) [1] = Reserved (set
    #  to 0) [31:2] = Mask for writable bits of BAR; set uppermost 31:n bits t
    # o 1, where 2^n=i/o aperture size in bytes.; EP=0xFFFF; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_9_ATTR_BAR1                                                0x0

		# ATTR_9
		#(OFFSET, MASK, VALUE)      (0XFD480024, 0x0000FFFFU ,0x00000000U)  */
    mask_write 0XFD480024 0x0000FFFF 0x00000000
		# Register : ATTR_10 @ 0XFD480028</p>

		# Specifies mask/settings for Base Address Register (BAR) 1 if BAR0 is a 3
    # 2-bit BAR, or the upper bits of \'7bBAR1,BAR0\'7d if BAR0 is a 64-bit BA
    # R. If BAR is not to be implemented, set to 32'h00000000. See BAR0 descri
    # ption if this functions as the upper bits of a 64-bit BAR. Bits are defi
    # ned as follows: Memory Space BAR (not upper bits of BAR0) [0] = Mem Spac
    # e Indicator (set to 0) [2:1] = Type field (10 for 64-bit, 00 for 32-bit)
    #  [3] = Prefetchable (0 or 1) [31:4] = Mask for writable bits of BAR; if
    # 32-bit BAR, set uppermost 31:n bits to 1, where 2^n=memory aperture size
    #  in bytes. If 64-bit BAR, set uppermost 63:n bits of \'7bBAR2,BAR1\'7d t
    # o 1. IO Space BAR 0] = IO Space Indicator (set to 1) [1] = Reserved (set
    #  to 0) [31:2] = Mask for writable bits of BAR; set uppermost 31:n bits t
    # o 1, where 2^n=i/o aperture size in bytes.; EP=0xFFFF; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_10_ATTR_BAR1                                               0x0

		# ATTR_10
		#(OFFSET, MASK, VALUE)      (0XFD480028, 0x0000FFFFU ,0x00000000U)  */
    mask_write 0XFD480028 0x0000FFFF 0x00000000
		# Register : ATTR_11 @ 0XFD48002C</p>

		# For an endpoint, specifies mask/settings for Base Address Register (BAR)
    #  2 if BAR1 is a 32-bit BAR, or the upper bits of \'7bBAR2,BAR1\'7d if BA
    # R1 is the lower part of a 64-bit BAR. If BAR is not to be implemented, s
    # et to 32'h00000000. See BAR1 description if this functions as the upper
    # bits of a 64-bit BAR. For a switch or root: This must be set to 00FF_FFF
    # F. For an endpoint, bits are defined as follows: Memory Space BAR (not u
    # pper bits of BAR1) [0] = Mem Space Indicator (set to 0) [2:1] = Type fie
    # ld (10 for 64-bit, 00 for 32-bit) [3] = Prefetchable (0 or 1) [31:4] = M
    # ask for writable bits of BAR; if 32-bit BAR, set uppermost 31:n bits to
    # 1, where 2^n=memory aperture size in bytes. If 64-bit BAR, set uppermost
    #  63:n bits of \'7bBAR3,BAR2\'7d to 1. IO Space BAR 0] = IO Space Indicat
    # or (set to 1) [1] = Reserved (set to 0) [31:2] = Mask for writable bits
    # of BAR; set uppermost 31:n bits to 1, where 2^n=i/o aperture size in byt
    # es.; EP=0x0004; RP=0xFFFF
		# PSU_PCIE_ATTRIB_ATTR_11_ATTR_BAR2                                               0x0

		# ATTR_11
		#(OFFSET, MASK, VALUE)      (0XFD48002C, 0x0000FFFFU ,0x00000000U)  */
    mask_write 0XFD48002C 0x0000FFFF 0x00000000
		# Register : ATTR_12 @ 0XFD480030</p>

		# For an endpoint, specifies mask/settings for Base Address Register (BAR)
    #  2 if BAR1 is a 32-bit BAR, or the upper bits of \'7bBAR2,BAR1\'7d if BA
    # R1 is the lower part of a 64-bit BAR. If BAR is not to be implemented, s
    # et to 32'h00000000. See BAR1 description if this functions as the upper
    # bits of a 64-bit BAR. For a switch or root: This must be set to 00FF_FFF
    # F. For an endpoint, bits are defined as follows: Memory Space BAR (not u
    # pper bits of BAR1) [0] = Mem Space Indicator (set to 0) [2:1] = Type fie
    # ld (10 for 64-bit, 00 for 32-bit) [3] = Prefetchable (0 or 1) [31:4] = M
    # ask for writable bits of BAR; if 32-bit BAR, set uppermost 31:n bits to
    # 1, where 2^n=memory aperture size in bytes. If 64-bit BAR, set uppermost
    #  63:n bits of \'7bBAR3,BAR2\'7d to 1. IO Space BAR 0] = IO Space Indicat
    # or (set to 1) [1] = Reserved (set to 0) [31:2] = Mask for writable bits
    # of BAR; set uppermost 31:n bits to 1, where 2^n=i/o aperture size in byt
    # es.; EP=0xFFF0; RP=0x00FF
		# PSU_PCIE_ATTRIB_ATTR_12_ATTR_BAR2                                               0x0

		# ATTR_12
		#(OFFSET, MASK, VALUE)      (0XFD480030, 0x0000FFFFU ,0x00000000U)  */
    mask_write 0XFD480030 0x0000FFFF 0x00000000
		# Register : ATTR_13 @ 0XFD480034</p>

		# For an endpoint, specifies mask/settings for Base Address Register (BAR)
    #  3 if BAR2 is a 32-bit BAR, or the upper bits of \'7bBAR3,BAR2\'7d if BA
    # R2 is the lower part of a 64-bit BAR. If BAR is not to be implemented, s
    # et to 32'h00000000. See BAR2 description if this functions as the upper
    # bits of a 64-bit BAR. For a switch or root, this must be set to: FFFF_00
    # 00 = IO Limit/Base Registers not implemented FFFF_F0F0 = IO Limit/Base R
    # egisters use 16-bit decode FFFF_F1F1 = IO Limit/Base Registers use 32-bi
    # t decode For an endpoint, bits are defined as follows: Memory Space BAR
    # (not upper bits of BAR2) [0] = Mem Space Indicator (set to 0) [2:1] = Ty
    # pe field (10 for 64-bit, 00 for 32-bit) [3] = Prefetchable (0 or 1) [31:
    # 4] = Mask for writable bits of BAR; if 32-bit BAR, set uppermost 31:n bi
    # ts to 1, where 2^n=memory aperture size in bytes. If 64-bit BAR, set upp
    # ermost 63:n bits of \'7bBAR4,BAR3\'7d to 1. IO Space BAR 0] = IO Space I
    # ndicator (set to 1) [1] = Reserved (set to 0) [31:2] = Mask for writable
    #  bits of BAR; set uppermost 31:n bits to 1, where 2^n=i/o aperture size
    # in bytes.; EP=0xFFFF; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_13_ATTR_BAR3                                               0x0

		# ATTR_13
		#(OFFSET, MASK, VALUE)      (0XFD480034, 0x0000FFFFU ,0x00000000U)  */
    mask_write 0XFD480034 0x0000FFFF 0x00000000
		# Register : ATTR_14 @ 0XFD480038</p>

		# For an endpoint, specifies mask/settings for Base Address Register (BAR)
    #  3 if BAR2 is a 32-bit BAR, or the upper bits of \'7bBAR3,BAR2\'7d if BA
    # R2 is the lower part of a 64-bit BAR. If BAR is not to be implemented, s
    # et to 32'h00000000. See BAR2 description if this functions as the upper
    # bits of a 64-bit BAR. For a switch or root, this must be set to: FFFF_00
    # 00 = IO Limit/Base Registers not implemented FFFF_F0F0 = IO Limit/Base R
    # egisters use 16-bit decode FFFF_F1F1 = IO Limit/Base Registers use 32-bi
    # t decode For an endpoint, bits are defined as follows: Memory Space BAR
    # (not upper bits of BAR2) [0] = Mem Space Indicator (set to 0) [2:1] = Ty
    # pe field (10 for 64-bit, 00 for 32-bit) [3] = Prefetchable (0 or 1) [31:
    # 4] = Mask for writable bits of BAR; if 32-bit BAR, set uppermost 31:n bi
    # ts to 1, where 2^n=memory aperture size in bytes. If 64-bit BAR, set upp
    # ermost 63:n bits of \'7bBAR4,BAR3\'7d to 1. IO Space BAR 0] = IO Space I
    # ndicator (set to 1) [1] = Reserved (set to 0) [31:2] = Mask for writable
    #  bits of BAR; set uppermost 31:n bits to 1, where 2^n=i/o aperture size
    # in bytes.; EP=0xFFFF; RP=0xFFFF
		# PSU_PCIE_ATTRIB_ATTR_14_ATTR_BAR3                                               0x0

		# ATTR_14
		#(OFFSET, MASK, VALUE)      (0XFD480038, 0x0000FFFFU ,0x00000000U)  */
    mask_write 0XFD480038 0x0000FFFF 0x00000000
		# Register : ATTR_15 @ 0XFD48003C</p>

		# For an endpoint, specifies mask/settings for Base Address Register (BAR)
    #  4 if BAR3 is a 32-bit BAR, or the upper bits of \'7bBAR4,BAR3\'7d if BA
    # R3 is the lower part of a 64-bit BAR. If BAR is not to be implemented, s
    # et to 32'h00000000. See BAR3 description if this functions as the upper
    # bits of a 64-bit BAR. For a switch or root: This must be set to FFF0_FFF
    # 0. For an endpoint, bits are defined as follows: Memory Space BAR (not u
    # pper bits of BAR3) [0] = Mem Space Indicator (set to 0) [2:1] = Type fie
    # ld (10 for 64-bit, 00 for 32-bit) [3] = Prefetchable (0 or 1) [31:4] = M
    # ask for writable bits of BAR; if 32-bit BAR, set uppermost 31:n bits to
    # 1, where 2^n=memory aperture size in bytes. If 64-bit BAR, set uppermost
    #  63:n bits of \'7bBAR5,BAR4\'7d to 1. IO Space BAR 0] = IO Space Indicat
    # or (set to 1) [1] = Reserved (set to 0) [31:2] = Mask for writable bits
    # of BAR; set uppermost 31:n bits to 1, where 2^n=i/o aperture size in byt
    # es.; EP=0x0004; RP=0xFFF0
		# PSU_PCIE_ATTRIB_ATTR_15_ATTR_BAR4                                               0x0

		# ATTR_15
		#(OFFSET, MASK, VALUE)      (0XFD48003C, 0x0000FFFFU ,0x00000000U)  */
    mask_write 0XFD48003C 0x0000FFFF 0x00000000
		# Register : ATTR_16 @ 0XFD480040</p>

		# For an endpoint, specifies mask/settings for Base Address Register (BAR)
    #  4 if BAR3 is a 32-bit BAR, or the upper bits of \'7bBAR4,BAR3\'7d if BA
    # R3 is the lower part of a 64-bit BAR. If BAR is not to be implemented, s
    # et to 32'h00000000. See BAR3 description if this functions as the upper
    # bits of a 64-bit BAR. For a switch or root: This must be set to FFF0_FFF
    # 0. For an endpoint, bits are defined as follows: Memory Space BAR (not u
    # pper bits of BAR3) [0] = Mem Space Indicator (set to 0) [2:1] = Type fie
    # ld (10 for 64-bit, 00 for 32-bit) [3] = Prefetchable (0 or 1) [31:4] = M
    # ask for writable bits of BAR; if 32-bit BAR, set uppermost 31:n bits to
    # 1, where 2^n=memory aperture size in bytes. If 64-bit BAR, set uppermost
    #  63:n bits of \'7bBAR5,BAR4\'7d to 1. IO Space BAR 0] = IO Space Indicat
    # or (set to 1) [1] = Reserved (set to 0) [31:2] = Mask for writable bits
    # of BAR; set uppermost 31:n bits to 1, where 2^n=i/o aperture size in byt
    # es.; EP=0xFFF0; RP=0xFFF0
		# PSU_PCIE_ATTRIB_ATTR_16_ATTR_BAR4                                               0x0

		# ATTR_16
		#(OFFSET, MASK, VALUE)      (0XFD480040, 0x0000FFFFU ,0x00000000U)  */
    mask_write 0XFD480040 0x0000FFFF 0x00000000
		# Register : ATTR_17 @ 0XFD480044</p>

		# For an endpoint, specifies mask/settings for Base Address Register (BAR)
    #  5 if BAR4 is a 32-bit BAR, or the upper bits of \'7bBAR5,BAR4\'7d if BA
    # R4 is the lower part of a 64-bit BAR. If BAR is not to be implemented, s
    # et to 32'h00000000. See BAR4 description if this functions as the upper
    # bits of a 64-bit BAR. For a switch or root, this must be set to: 0000_00
    # 00 = Prefetchable Memory Limit/Base Registers not implemented FFF0_FFF0
    # = 32-bit Prefetchable Memory Limit/Base implemented FFF1_FFF1 = 64-bit P
    # refetchable Memory Limit/Base implemented For an endpoint, bits are defi
    # ned as follows: Memory Space BAR (not upper bits of BAR4) [0] = Mem Spac
    # e Indicator (set to 0) [2:1] = Type field (00 for 32-bit; BAR5 cannot be
    #  lower part of a 64-bit BAR) [3] = Prefetchable (0 or 1) [31:4] = Mask f
    # or writable bits of BAR; set uppermost 31:n bits to 1, where 2^n=memory
    # aperture size in bytes. IO Space BAR 0] = IO Space Indicator (set to 1)
    # [1] = Reserved (set to 0) [31:2] = Mask for writable bits of BAR; set up
    # permost 31:n bits to 1, where 2^n=i/o aperture size in bytes.; EP=0xFFFF
    # ; RP=0xFFF1
		# PSU_PCIE_ATTRIB_ATTR_17_ATTR_BAR5                                               0x0

		# ATTR_17
		#(OFFSET, MASK, VALUE)      (0XFD480044, 0x0000FFFFU ,0x00000000U)  */
    mask_write 0XFD480044 0x0000FFFF 0x00000000
		# Register : ATTR_18 @ 0XFD480048</p>

		# For an endpoint, specifies mask/settings for Base Address Register (BAR)
    #  5 if BAR4 is a 32-bit BAR, or the upper bits of \'7bBAR5,BAR4\'7d if BA
    # R4 is the lower part of a 64-bit BAR. If BAR is not to be implemented, s
    # et to 32'h00000000. See BAR4 description if this functions as the upper
    # bits of a 64-bit BAR. For a switch or root, this must be set to: 0000_00
    # 00 = Prefetchable Memory Limit/Base Registers not implemented FFF0_FFF0
    # = 32-bit Prefetchable Memory Limit/Base implemented FFF1_FFF1 = 64-bit P
    # refetchable Memory Limit/Base implemented For an endpoint, bits are defi
    # ned as follows: Memory Space BAR (not upper bits of BAR4) [0] = Mem Spac
    # e Indicator (set to 0) [2:1] = Type field (00 for 32-bit; BAR5 cannot be
    #  lower part of a 64-bit BAR) [3] = Prefetchable (0 or 1) [31:4] = Mask f
    # or writable bits of BAR; set uppermost 31:n bits to 1, where 2^n=memory
    # aperture size in bytes. IO Space BAR 0] = IO Space Indicator (set to 1)
    # [1] = Reserved (set to 0) [31:2] = Mask for writable bits of BAR; set up
    # permost 31:n bits to 1, where 2^n=i/o aperture size in bytes.; EP=0xFFFF
    # ; RP=0xFFF1
		# PSU_PCIE_ATTRIB_ATTR_18_ATTR_BAR5                                               0x0

		# ATTR_18
		#(OFFSET, MASK, VALUE)      (0XFD480048, 0x0000FFFFU ,0x00000000U)  */
    mask_write 0XFD480048 0x0000FFFF 0x00000000
		# Register : ATTR_27 @ 0XFD48006C</p>

		# Specifies maximum payload supported. Valid settings are: 0- 128 bytes, 1
    # - 256 bytes, 2- 512 bytes, 3- 1024 bytes. Transferred to the Device Capa
    # bilities register. The values: 4-2048 bytes, 5- 4096 bytes are not suppo
    # rted; EP=0x0001; RP=0x0001
		# PSU_PCIE_ATTRIB_ATTR_27_ATTR_DEV_CAP_MAX_PAYLOAD_SUPPORTED                      1

		# Endpoint L1 Acceptable Latency. Records the latency that the endpoint ca
    # n withstand on transitions from L1 state to L0 (if L1 state supported).
    # Valid settings are: 0h less than 1us, 1h 1 to 2us, 2h 2 to 4us, 3h 4 to
    # 8us, 4h 8 to 16us, 5h 16 to 32us, 6h 32 to 64us, 7h more than 64us. For
    # Endpoints only. Must be 0h for other devices.; EP=0x0007; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_27_ATTR_DEV_CAP_ENDPOINT_L1_LATENCY                        0x7

		# ATTR_27
		#(OFFSET, MASK, VALUE)      (0XFD48006C, 0x00000738U ,0x00000138U)  */
    mask_write 0XFD48006C 0x00000738 0x00000138
		# Register : ATTR_50 @ 0XFD4800C8</p>

		# Identifies the type of device/port as follows: 0000b PCI Express Endpoin
    # t device, 0001b Legacy PCI Express Endpoint device, 0100b Root Port of P
    # CI Express Root Complex, 0101b Upstream Port of PCI Express Switch, 0110
    # b Downstream Port of PCI Express Switch, 0111b PCIE Express to PCI/PCI-X
    #  Bridge, 1000b PCI/PCI-X to PCI Express Bridge. Transferred to PCI Expre
    # ss Capabilities register. Must be consistent with IS_SWITCH and UPSTREAM
    # _FACING settings.; EP=0x0000; RP=0x0004
		# PSU_PCIE_ATTRIB_ATTR_50_ATTR_PCIE_CAP_DEVICE_PORT_TYPE                          0x0

		# PCIe Capability's Next Capability Offset pointer to the next item in the
    #  capabilities list, or 00h if this is the final capability.; EP=0x009C;
    # RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_50_ATTR_PCIE_CAP_NEXTPTR                                   0

		# ATTR_50
		#(OFFSET, MASK, VALUE)      (0XFD4800C8, 0x0000FFF0U ,0x00000000U)  */
    mask_write 0XFD4800C8 0x0000FFF0 0x00000000
		# Register : ATTR_105 @ 0XFD4801A4</p>

		# Number of credits that should be advertised for Completion data received
    #  on Virtual Channel 0. The bytes advertised must be less than or equal t
    # o the bram bytes available. See VC0_RX_RAM_LIMIT; EP=0x0172; RP=0x00CD
		# PSU_PCIE_ATTRIB_ATTR_105_ATTR_VC0_TOTAL_CREDITS_CD                              0x172

		# ATTR_105
		#(OFFSET, MASK, VALUE)      (0XFD4801A4, 0x000007FFU ,0x00000172U)  */
    mask_write 0XFD4801A4 0x000007FF 0x00000172
		# Register : ATTR_106 @ 0XFD4801A8</p>

		# Number of credits that should be advertised for Completion headers recei
    # ved on Virtual Channel 0. The sum of the posted, non posted, and complet
    # ion header credits must be <= 80; EP=0x0048; RP=0x0024
		# PSU_PCIE_ATTRIB_ATTR_106_ATTR_VC0_TOTAL_CREDITS_CH                              0x48

		# Number of credits that should be advertised for Non-Posted headers recei
    # ved on Virtual Channel 0. The number of non posted data credits advertis
    # ed by the block is equal to the number of non posted header credits. The
    #  sum of the posted, non posted, and completion header credits must be <=
    #  80; EP=0x0004; RP=0x000C
		# PSU_PCIE_ATTRIB_ATTR_106_ATTR_VC0_TOTAL_CREDITS_NPH                             0x4

		# ATTR_106
		#(OFFSET, MASK, VALUE)      (0XFD4801A8, 0x00003FFFU ,0x00000248U)  */
    mask_write 0XFD4801A8 0x00003FFF 0x00000248
		# Register : ATTR_107 @ 0XFD4801AC</p>

		# Number of credits that should be advertised for Non-Posted data received
    #  on Virtual Channel 0. The number of non posted data credits advertised
    # by the block is equal to two times the number of non posted header credi
    # ts if atomic operations are supported or is equal to the number of non p
    # osted header credits if atomic operations are not supported. The bytes a
    # dvertised must be less than or equal to the bram bytes available. See VC
    # 0_RX_RAM_LIMIT; EP=0x0008; RP=0x0018
		# PSU_PCIE_ATTRIB_ATTR_107_ATTR_VC0_TOTAL_CREDITS_NPD                             0x8

		# ATTR_107
		#(OFFSET, MASK, VALUE)      (0XFD4801AC, 0x000007FFU ,0x00000008U)  */
    mask_write 0XFD4801AC 0x000007FF 0x00000008
		# Register : ATTR_108 @ 0XFD4801B0</p>

		# Number of credits that should be advertised for Posted data received on
    # Virtual Channel 0. The bytes advertised must be less than or equal to th
    # e bram bytes available. See VC0_RX_RAM_LIMIT; EP=0x0020; RP=0x00B5
		# PSU_PCIE_ATTRIB_ATTR_108_ATTR_VC0_TOTAL_CREDITS_PD                              0x20

		# ATTR_108
		#(OFFSET, MASK, VALUE)      (0XFD4801B0, 0x000007FFU ,0x00000020U)  */
    mask_write 0XFD4801B0 0x000007FF 0x00000020
		# Register : ATTR_109 @ 0XFD4801B4</p>

		# Not currently in use. Invert ECRC generated by block when trn_tecrc_gen_
    # n and trn_terrfwd_n are asserted.; EP=0x0000; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_109_ATTR_TECRC_EP_INV                                      0x0

		# Enables td bit clear and ECRC trim on received TLP's FALSE == don't trim
    #  TRUE == trim.; EP=0x0001; RP=0x0001
		# PSU_PCIE_ATTRIB_ATTR_109_ATTR_RECRC_CHK_TRIM                                    0x1

		# Enables ECRC check on received TLP's 0 == don't check 1 == always check
    # 3 == check if enabled by ECRC check enable bit of AER cap structure; EP=
    # 0x0003; RP=0x0003
		# PSU_PCIE_ATTRIB_ATTR_109_ATTR_RECRC_CHK                                         0x3

		# Index of last packet buffer used by TX TLM (i.e. number of buffers - 1).
    #  Calculated from max payload size supported and the number of brams conf
    # igured for transmit; EP=0x001C; RP=0x001C
		# PSU_PCIE_ATTRIB_ATTR_109_ATTR_VC0_TX_LASTPACKET                                 0x1c

		# Number of credits that should be advertised for Posted headers received
    # on Virtual Channel 0. The sum of the posted, non posted, and completion
    # header credits must be <= 80; EP=0x0004; RP=0x0020
		# PSU_PCIE_ATTRIB_ATTR_109_ATTR_VC0_TOTAL_CREDITS_PH                              0x4

		# ATTR_109
		#(OFFSET, MASK, VALUE)      (0XFD4801B4, 0x0000FFFFU ,0x00007E04U)  */
    mask_write 0XFD4801B4 0x0000FFFF 0x00007E04
		# Register : ATTR_34 @ 0XFD480088</p>

		# Specifies values to be transferred to Header Type register. Bit 7 should
    #  be set to '0' indicating single-function device. Bit 0 identifies heade
    # r as Type 0 or Type 1, with '0' indicating a Type 0 header.; EP=0x0000;
    # RP=0x0001
		# PSU_PCIE_ATTRIB_ATTR_34_ATTR_HEADER_TYPE                                        0x0

		# Indicates mapping for legacy interrupt messages. Valid values are 1 INTA
    # , 2 INTB, 3 INTC, 4 INTD. Zero indicates no legacy interrupt messages us
    # ed.; EP=0x0001; RP=0x0001
		# PSU_PCIE_ATTRIB_ATTR_34_ATTR_INTERRUPT_PIN                                      1

		# ATTR_34
		#(OFFSET, MASK, VALUE)      (0XFD480088, 0x0000FFFFU ,0x00000100U)  */
    mask_write 0XFD480088 0x0000FFFF 0x00000100
		# Register : ATTR_53 @ 0XFD4800D4</p>

		# PM Capability's Next Capability Offset pointer to the next item in the c
    # apabilities list, or 00h if this is the final capability.; EP=0x0048; RP
    # =0x0060
		# PSU_PCIE_ATTRIB_ATTR_53_ATTR_PM_CAP_NEXTPTR                                     0x60

		# ATTR_53
		#(OFFSET, MASK, VALUE)      (0XFD4800D4, 0x000000FFU ,0x00000060U)  */
    mask_write 0XFD4800D4 0x000000FF 0x00000060
		# Register : ATTR_41 @ 0XFD4800A4</p>

		# MSI Per-Vector Masking Capable. The value is transferred to the MSI Cont
    # rol Register[8]. When set, adds Mask and Pending Dword to Cap structure;
    #  EP=0x0000; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_41_ATTR_MSI_CAP_PER_VECTOR_MASKING_CAPABLE                 0x0

		# Indicates that the MSI structures exists. If this is FALSE, then the MSI
    #  structure cannot be accessed via either the link or the management port
    # .; EP=0x0001; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_41_ATTR_MSI_CAP_ON                                         0

		# MSI Capability's Next Capability Offset pointer to the next item in the
    # capabilities list, or 00h if this is the final capability.; EP=0x0060; R
    # P=0x0000
		# PSU_PCIE_ATTRIB_ATTR_41_ATTR_MSI_CAP_NEXTPTR                                    0x60

		# Indicates that the MSI structures exists. If this is FALSE, then the MSI
    #  structure cannot be accessed via either the link or the management port
    # .; EP=0x0001; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_41_ATTR_MSI_CAP_ON                                         0

		# ATTR_41
		#(OFFSET, MASK, VALUE)      (0XFD4800A4, 0x000003FFU ,0x00000060U)  */
    mask_write 0XFD4800A4 0x000003FF 0x00000060
		# Register : ATTR_97 @ 0XFD480184</p>

		# Maximum Link Width. Valid settings are: 000001b x1, 000010b x2, 000100b
    # x4, 001000b x8.; EP=0x0004; RP=0x0004
		# PSU_PCIE_ATTRIB_ATTR_97_ATTR_LINK_CAP_MAX_LINK_WIDTH                            0x1

		# Used by LTSSM to set Maximum Link Width. Valid settings are: 000001b [x1
    # ], 000010b [x2], 000100b [x4], 001000b [x8].; EP=0x0004; RP=0x0004
		# PSU_PCIE_ATTRIB_ATTR_97_ATTR_LTSSM_MAX_LINK_WIDTH                               0x1

		# ATTR_97
		#(OFFSET, MASK, VALUE)      (0XFD480184, 0x00000FFFU ,0x00000041U)  */
    mask_write 0XFD480184 0x00000FFF 0x00000041
		# Register : ATTR_100 @ 0XFD480190</p>

		# TRUE specifies upstream-facing port. FALSE specifies downstream-facing p
    # ort.; EP=0x0001; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_100_ATTR_UPSTREAM_FACING                                   0x1

		# ATTR_100
		#(OFFSET, MASK, VALUE)      (0XFD480190, 0x00000040U ,0x00000040U)  */
    mask_write 0XFD480190 0x00000040 0x00000040
		# Register : ATTR_101 @ 0XFD480194</p>

		# Enable the routing of message TLPs to the user through the TRN RX interf
    # ace. A bit value of 1 enables routing of the message TLP to the user. Me
    # ssages are always decoded by the message decoder. Bit 0 - ERR COR, Bit 1
    #  - ERR NONFATAL, Bit 2 - ERR FATAL, Bit 3 - INTA Bit 4 - INTB, Bit 5 - I
    # NTC, Bit 6 - INTD, Bit 7 PM_PME, Bit 8 - PME_TO_ACK, Bit 9 - unlock, Bit
    #  10 PME_Turn_Off; EP=0x0000; RP=0x07FF
		# PSU_PCIE_ATTRIB_ATTR_101_ATTR_ENABLE_MSG_ROUTE                                  0x0

		# Disable BAR filtering. Does not change the behavior of the bar hit outpu
    # ts; EP=0x0000; RP=0x0001
		# PSU_PCIE_ATTRIB_ATTR_101_ATTR_DISABLE_BAR_FILTERING                             0x0

		# ATTR_101
		#(OFFSET, MASK, VALUE)      (0XFD480194, 0x0000FFE2U ,0x00000000U)  */
    mask_write 0XFD480194 0x0000FFE2 0x00000000
		# Register : ATTR_37 @ 0XFD480094</p>

		# Maximum Link Speed. Valid settings are: 0001b [2.5 GT/s], 0010b [5.0 GT/
    # s and 2.5 GT/s].; EP=0x0002; RP=0x0002
		# PSU_PCIE_ATTRIB_ATTR_37_ATTR_LINK_CAP_MAX_LINK_SPEED                            0x2

		# Sets the ASPM Optionality Compliance bit, to comply with the 2.1 ASPM Op
    # tionality ECN. Transferred to the Link Capabilities register.; EP=0x0001
    # ; RP=0x0001
		# PSU_PCIE_ATTRIB_ATTR_37_ATTR_LINK_CAP_ASPM_OPTIONALITY                          0x1

		# ATTR_37
		#(OFFSET, MASK, VALUE)      (0XFD480094, 0x00007C00U ,0x00004800U)  */
    mask_write 0XFD480094 0x00007C00 0x00004800
		# Register : ID @ 0XFD480200</p>

		# Device ID for the the PCIe Cap Structure Device ID field
		# PSU_PCIE_ATTRIB_ID_CFG_DEV_ID                                                   0xd011

		# Vendor ID for the PCIe Cap Structure Vendor ID field
		# PSU_PCIE_ATTRIB_ID_CFG_VEND_ID                                                  0x10ee

		# ID
		#(OFFSET, MASK, VALUE)      (0XFD480200, 0xFFFFFFFFU ,0x10EED011U)  */
    mask_write 0XFD480200 0xFFFFFFFF 0x10EED011
		# Register : SUBSYS_ID @ 0XFD480204</p>

		# Subsystem ID for the the PCIe Cap Structure Subsystem ID field
		# PSU_PCIE_ATTRIB_SUBSYS_ID_CFG_SUBSYS_ID                                         0x7

		# Subsystem Vendor ID for the PCIe Cap Structure Subsystem Vendor ID field
		# PSU_PCIE_ATTRIB_SUBSYS_ID_CFG_SUBSYS_VEND_ID                                    0x10ee

		# SUBSYS_ID
		#(OFFSET, MASK, VALUE)      (0XFD480204, 0xFFFFFFFFU ,0x10EE0007U)  */
    mask_write 0XFD480204 0xFFFFFFFF 0x10EE0007
		# Register : REV_ID @ 0XFD480208</p>

		# Revision ID for the the PCIe Cap Structure
		# PSU_PCIE_ATTRIB_REV_ID_CFG_REV_ID                                               0x0

		# REV_ID
		#(OFFSET, MASK, VALUE)      (0XFD480208, 0x000000FFU ,0x00000000U)  */
    mask_write 0XFD480208 0x000000FF 0x00000000
		# Register : ATTR_24 @ 0XFD480060</p>

		# Code identifying basic function, subclass and applicable programming int
    # erface. Transferred to the Class Code register.; EP=0x8000; RP=0x8000
		# PSU_PCIE_ATTRIB_ATTR_24_ATTR_CLASS_CODE                                         0x8000

		# ATTR_24
		#(OFFSET, MASK, VALUE)      (0XFD480060, 0x0000FFFFU ,0x00008000U)  */
    mask_write 0XFD480060 0x0000FFFF 0x00008000
		# Register : ATTR_25 @ 0XFD480064</p>

		# Code identifying basic function, subclass and applicable programming int
    # erface. Transferred to the Class Code register.; EP=0x0005; RP=0x0006
		# PSU_PCIE_ATTRIB_ATTR_25_ATTR_CLASS_CODE                                         0x5

		# INTX Interrupt Generation Capable. If FALSE, this will cause Command[10]
    #  to be hardwired to 0.; EP=0x0001; RP=0x0001
		# PSU_PCIE_ATTRIB_ATTR_25_ATTR_CMD_INTX_IMPLEMENTED                               1

		# ATTR_25
		#(OFFSET, MASK, VALUE)      (0XFD480064, 0x000001FFU ,0x00000105U)  */
    mask_write 0XFD480064 0x000001FF 0x00000105
		# Register : BRIDGE_CORE_CFG_PCIE_RX0 @ 0XFD0E0000</p>

		# Determines which PCI Express Base Address Region (BAR) is used to access
    #  DMA and Bridge Registers from PCI Express. If a received PCI Express re
    # ad/write requests' BAR hit information is equal to cfg_dma_reg_bar, then
    #  the transaction is terminated by the internal DMA/Bridge Register imple
    # mentation, otherwise the transaction is forwarded to the AXI Master Inte
    # rface. cfg_dma_reg_bar is only for received PCI Express read and write r
    # equests and has no impact on received AXI Slave Interface requests.
		# PSU_AXIPCIE_MAIN_BRIDGE_CORE_CFG_PCIE_RX0_CFG_DMA_REG_BAR                       0x0

		# PCI Express Receive Access and BAR Configuration
		#(OFFSET, MASK, VALUE)      (0XFD0E0000, 0x00000007U ,0x00000000U)  */
    mask_write 0XFD0E0000 0x00000007 0x00000000
		# Register : ATTR_4 @ 0XFD480010</p>

		# Indicates that the AER structures exists. If this is FALSE, then the AER
    #  structure cannot be accessed via either the link or the management port
    # , and AER will be considered to not be present for error management task
    # s (such as what types of error messages are sent if an error is detected
    # ).; EP=0x0001; RP=0x0001
		# PSU_PCIE_ATTRIB_ATTR_4_ATTR_AER_CAP_ON                                          0

		# Indicates that the AER structures exists. If this is FALSE, then the AER
    #  structure cannot be accessed via either the link or the management port
    # , and AER will be considered to not be present for error management task
    # s (such as what types of error messages are sent if an error is detected
    # ).; EP=0x0001; RP=0x0001
		# PSU_PCIE_ATTRIB_ATTR_4_ATTR_AER_CAP_ON                                          0

		# ATTR_4
		#(OFFSET, MASK, VALUE)      (0XFD480010, 0x00001000U ,0x00000000U)  */
    mask_write 0XFD480010 0x00001000 0x00000000
		# Register : ATTR_89 @ 0XFD480164</p>

		# VSEC's Next Capability Offset pointer to the next item in the capabiliti
    # es list, or 000h if this is the final capability.; EP=0x0140; RP=0x0140
		# PSU_PCIE_ATTRIB_ATTR_89_ATTR_VSEC_CAP_NEXTPTR                                   0

		# ATTR_89
		#(OFFSET, MASK, VALUE)      (0XFD480164, 0x00001FFEU ,0x00000000U)  */
    mask_write 0XFD480164 0x00001FFE 0x00000000
		# Register : ATTR_43 @ 0XFD4800AC</p>

		# Indicates that the MSIX structures exists. If this is FALSE, then the MS
    # IX structure cannot be accessed via either the link or the management po
    # rt.; EP=0x0001; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_43_ATTR_MSIX_CAP_ON                                        0

		# MSI-X Pending Bit Array BIR. This value is transferred to the MSI-X PBA
    # BIR field. Set to 0 if MSI-X is not enabled.; EP=0x0000; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_43_ATTR_MSIX_CAP_PBA_BIR                                   0x0

		# ATTR_43
		#(OFFSET, MASK, VALUE)      (0XFD4800AC, 0x00000F00U ,0x00000000U)  */
    mask_write 0XFD4800AC 0x00000F00 0x00000000
		# Register : ATTR_45 @ 0XFD4800B4</p>

		# MSI-X Table BIR. This value is transferred to the MSI-X Table BIR field.
    #  Set to 0 if MSI-X is not enabled.; EP=0x0000; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_45_ATTR_MSIX_CAP_TABLE_BIR                                 0x0

		# ATTR_45
		#(OFFSET, MASK, VALUE)      (0XFD4800B4, 0x00000007U ,0x00000000U)  */
    mask_write 0XFD4800B4 0x00000007 0x00000000
		# Register : CB @ 0XFD48031C</p>

		# DT837748 Enable
		# PSU_PCIE_ATTRIB_CB_CB1                                                          0x0

		# ECO Register 1
		#(OFFSET, MASK, VALUE)      (0XFD48031C, 0x00000002U ,0x00000000U)  */
    mask_write 0XFD48031C 0x00000002 0x00000000
		# Register : ATTR_35 @ 0XFD48008C</p>

		# Active State PM Support. Indicates the level of active state power manag
    # ement supported by the selected PCI Express Link, encoded as follows: 0
    # Reserved, 1 L0s entry supported, 2 Reserved, 3 L0s and L1 entry supporte
    # d.; EP=0x0001; RP=0x0001
		# PSU_PCIE_ATTRIB_ATTR_35_ATTR_LINK_CAP_ASPM_SUPPORT                              0x0

		# Data Link Layer Link Active status notification is supported. This is op
    # tional for Upstream ports.; EP=0x0000; RP=0x0000
		# PSU_PCIE_ATTRIB_ATTR_35_ATTR_LINK_CAP_DLL_LINK_ACTIVE_REPORTING_CAP             1

		# ATTR_35
		#(OFFSET, MASK, VALUE)      (0XFD48008C, 0x0000B000U ,0x00008000U)  */
    mask_write 0XFD48008C 0x0000B000 0x00008000
		# : PUTTING PCIE CONTROL IN RESET
		# Register : RST_FPD_TOP @ 0XFD1A0100</p>

		# PCIE control block level reset
		# PSU_CRF_APB_RST_FPD_TOP_PCIE_CTRL_RESET                                         0X0

		# FPD Block level software controlled reset
		#(OFFSET, MASK, VALUE)      (0XFD1A0100, 0x00020000U ,0x00000000U)  */
    mask_write 0XFD1A0100 0x00020000 0x00000000
		# : CHECK PLL LOCK FOR LANE0
		# Register : L0_PLL_STATUS_READ_1 @ 0XFD4023E4</p>

		# Status Read value of PLL Lock
		# PSU_SERDES_L0_PLL_STATUS_READ_1_PLL_LOCK_STATUS_READ                            1
    mask_poll 0XFD4023E4 0x00000010
		# : SATA AHCI VENDOR SETTING
}

set psu_resetin_init_data {
		# : PUTTING SERDES PERIPHERAL IN RESET
		# : PUTTING USB0 IN RESET
		# Register : RST_LPD_TOP @ 0XFF5E023C</p>

		# USB 0 reset for control registers
		# PSU_CRL_APB_RST_LPD_TOP_USB0_APB_RESET                                          0X1

		# USB 0 sleep circuit reset
		# PSU_CRL_APB_RST_LPD_TOP_USB0_HIBERRESET                                         0X1

		# USB 0 reset
		# PSU_CRL_APB_RST_LPD_TOP_USB0_CORERESET                                          0X1

		# Software control register for the LPD block.
		#(OFFSET, MASK, VALUE)      (0XFF5E023C, 0x00000540U ,0x00000540U)  */
    mask_write 0XFF5E023C 0x00000540 0x00000540
		# : PUTTING PCIE IN RESET
		# Register : RST_FPD_TOP @ 0XFD1A0100</p>

		# PCIE config reset
		# PSU_CRF_APB_RST_FPD_TOP_PCIE_CFG_RESET                                          0X1

		# PCIE control block level reset
		# PSU_CRF_APB_RST_FPD_TOP_PCIE_CTRL_RESET                                         0X1

		# PCIE bridge block level reset (AXI interface)
		# PSU_CRF_APB_RST_FPD_TOP_PCIE_BRIDGE_RESET                                       0X1

		# FPD Block level software controlled reset
		#(OFFSET, MASK, VALUE)      (0XFD1A0100, 0x000E0000U ,0x000E0000U)  */
    mask_write 0XFD1A0100 0x000E0000 0x000E0000
}

set psu_ps_pl_isolation_removal_data {
		# : PS-PL POWER UP REQUEST
		# Register : REQ_PWRUP_INT_EN @ 0XFFD80118</p>

		# Power-up Request Interrupt Enable for PL
		# PSU_PMU_GLOBAL_REQ_PWRUP_INT_EN_PL                                              1

		# Power-up Request Interrupt Enable Register. Writing a 1 to this location
    #  will unmask the interrupt.
		#(OFFSET, MASK, VALUE)      (0XFFD80118, 0x00800000U ,0x00800000U)  */
    mask_write 0XFFD80118 0x00800000 0x00800000
		# Register : REQ_PWRUP_TRIG @ 0XFFD80120</p>

		# Power-up Request Trigger for PL
		# PSU_PMU_GLOBAL_REQ_PWRUP_TRIG_PL                                                1

		# Power-up Request Trigger Register. A write of one to this location will
    # generate a power-up request to the PMU.
		#(OFFSET, MASK, VALUE)      (0XFFD80120, 0x00800000U ,0x00800000U)  */
    mask_write 0XFFD80120 0x00800000 0x00800000
		# : POLL ON PL POWER STATUS
		# Register : REQ_PWRUP_STATUS @ 0XFFD80110</p>

		# Power-up Request Status for PL
		# PSU_PMU_GLOBAL_REQ_PWRUP_STATUS_PL                                              1
    mask_poll 0XFFD80110 0x00800000 0x00000000
}

set psu_afi_config {
		# : AFI RESET
		# Register : RST_FPD_TOP @ 0XFD1A0100</p>

		# AF_FM0 block level reset
		# PSU_CRF_APB_RST_FPD_TOP_AFI_FM0_RESET                                           0

		# AF_FM1 block level reset
		# PSU_CRF_APB_RST_FPD_TOP_AFI_FM1_RESET                                           0

		# AF_FM2 block level reset
		# PSU_CRF_APB_RST_FPD_TOP_AFI_FM2_RESET                                           0

		# AF_FM3 block level reset
		# PSU_CRF_APB_RST_FPD_TOP_AFI_FM3_RESET                                           0

		# AF_FM4 block level reset
		# PSU_CRF_APB_RST_FPD_TOP_AFI_FM4_RESET                                           0

		# AF_FM5 block level reset
		# PSU_CRF_APB_RST_FPD_TOP_AFI_FM5_RESET                                           0

		# FPD Block level software controlled reset
		#(OFFSET, MASK, VALUE)      (0XFD1A0100, 0x00001F80U ,0x00000000U)  */
    mask_write 0XFD1A0100 0x00001F80 0x00000000
		# Register : RST_LPD_TOP @ 0XFF5E023C</p>

		# AFI FM 6
		# PSU_CRL_APB_RST_LPD_TOP_AFI_FM6_RESET                                           0

		# Software control register for the LPD block.
		#(OFFSET, MASK, VALUE)      (0XFF5E023C, 0x00080000U ,0x00000000U)  */
    mask_write 0XFF5E023C 0x00080000 0x00000000
		# : AFIFM INTERFACE WIDTH
		# Register : afi_fs @ 0XFD615000</p>

		# Select the 32/64/128-bit data width selection for the Slave 0 00: 32-bit
    #  AXI data width (default) 01: 64-bit AXI data width 10: 128-bit AXI data
    #  width 11: reserved
		# PSU_FPD_SLCR_AFI_FS_DW_SS0_SEL                                                  0x2

		# afi fs SLCR control register. This register is static and should not be
    # modified during operation.
		#(OFFSET, MASK, VALUE)      (0XFD615000, 0x00000300U ,0x00000200U)  */
    mask_write 0XFD615000 0x00000300 0x00000200
		# Register : AFIFM_RDCTRL @ 0XFD380000</p>

		# Configures the Read Channel Fabric interface width. 2'b11 : Reserved 2'b
    # 10 : 32-bit Fabric 2'b01 : 64-bit enabled 2'b00 : 128-bit enabled
		# PSU_AFIFM2_AFIFM_RDCTRL_FABRIC_WIDTH                                            0x2

		# Read Channel Control Register
		#(OFFSET, MASK, VALUE)      (0XFD380000, 0x00000003U ,0x00000002U)  */
    mask_write 0XFD380000 0x00000003 0x00000002
		# Register : AFIFM_WRCTRL @ 0XFD380014</p>

		# Configures the Write Channel Fabric interface width. 2'b11 : Reserved 2'
    # b10 : 32-bit Fabric 2'b01 : 64-bit enabled 2'b00 : 128-bit enabled
		# PSU_AFIFM2_AFIFM_WRCTRL_FABRIC_WIDTH                                            0x2

		# Write Channel Control Register
		#(OFFSET, MASK, VALUE)      (0XFD380014, 0x00000003U ,0x00000002U)  */
    mask_write 0XFD380014 0x00000003 0x00000002
}

set psu_ps_pl_reset_config_data {
		# : PS PL RESET SEQUENCE
		# : FABRIC RESET USING EMIO
		# Register : MASK_DATA_5_MSW @ 0XFF0A002C</p>

		# Operation is the same as MASK_DATA_0_LSW[MASK_0_LSW]
		# PSU_GPIO_MASK_DATA_5_MSW_MASK_5_MSW                                             0x8000

		# Maskable Output Data (GPIO Bank5, EMIO, Upper 16bits)
		#(OFFSET, MASK, VALUE)      (0XFF0A002C, 0xFFFF0000U ,0x80000000U)  */
    mask_write 0XFF0A002C 0xFFFF0000 0x80000000
		# Register : DIRM_5 @ 0XFF0A0344</p>

		# Operation is the same as DIRM_0[DIRECTION_0]
		# PSU_GPIO_DIRM_5_DIRECTION_5                                                     0x80000000

		# Direction mode (GPIO Bank5, EMIO)
		#(OFFSET, MASK, VALUE)      (0XFF0A0344, 0xFFFFFFFFU ,0x80000000U)  */
    mask_write 0XFF0A0344 0xFFFFFFFF 0x80000000
		# Register : OEN_5 @ 0XFF0A0348</p>

		# Operation is the same as OEN_0[OP_ENABLE_0]
		# PSU_GPIO_OEN_5_OP_ENABLE_5                                                      0x80000000

		# Output enable (GPIO Bank5, EMIO)
		#(OFFSET, MASK, VALUE)      (0XFF0A0348, 0xFFFFFFFFU ,0x80000000U)  */
    mask_write 0XFF0A0348 0xFFFFFFFF 0x80000000
		# Register : DATA_5 @ 0XFF0A0054</p>

		# Output Data
		# PSU_GPIO_DATA_5_DATA_5                                                          0x80000000

		# Output Data (GPIO Bank5, EMIO)
		#(OFFSET, MASK, VALUE)      (0XFF0A0054, 0xFFFFFFFFU ,0x80000000U)  */
    mask_write 0XFF0A0054 0xFFFFFFFF 0x80000000
    mask_delay 0x00000000 1
		# : FABRIC RESET USING DATA_5 TOGGLE
		# Register : DATA_5 @ 0XFF0A0054</p>

		# Output Data
		# PSU_GPIO_DATA_5_DATA_5                                                          0X00000000

		# Output Data (GPIO Bank5, EMIO)
		#(OFFSET, MASK, VALUE)      (0XFF0A0054, 0xFFFFFFFFU ,0x00000000U)  */
    mask_write 0XFF0A0054 0xFFFFFFFF 0x00000000
    mask_delay 0x00000000 1
		# : FABRIC RESET USING DATA_5 TOGGLE
		# Register : DATA_5 @ 0XFF0A0054</p>

		# Output Data
		# PSU_GPIO_DATA_5_DATA_5                                                          0x80000000

		# Output Data (GPIO Bank5, EMIO)
		#(OFFSET, MASK, VALUE)      (0XFF0A0054, 0xFFFFFFFFU ,0x80000000U)  */
    mask_write 0XFF0A0054 0xFFFFFFFF 0x80000000
}

proc psu_init {} {
    # save current mode
    set saved_mode [configparams force-mem-accesses]                  
    # force accesses
    configparams force-mem-accesses 1 
    variable psu_mio_init_data 
    variable psu_peripherals_pre_init_data
    variable psu_pll_init_data 
    variable psu_clock_init_data
	variable psu_ddr_init_data
    variable psu_peripherals_init_data
    variable psu_resetin_init_data
    variable psu_resetout_init_data
    variable psu_serdes_init_data
    variable psu_resetin_init_data
    variable psu_peripherals_powerdwn_data 
    variable psu_afi_config 
    variable psu_ddr_qos_init_data

    init_ps [subst {$psu_mio_init_data $psu_peripherals_pre_init_data $psu_pll_init_data $psu_clock_init_data $psu_ddr_init_data }]
    psu_ddr_phybringup_data 
    init_ps [subst {$psu_peripherals_init_data $psu_resetin_init_data }]
    init_serdes 
    init_ps [subst {$psu_serdes_init_data $psu_resetout_init_data }]
    init_peripheral 
    init_ps [subst {$psu_peripherals_powerdwn_data }]
    init_ps [subst {$psu_afi_config }]
    init_ps [subst {$psu_ddr_qos_init_data}]
    # restore original mode
    configparams force-mem-accesses $saved_mode                                       
}

proc psu_post_config {} {
    variable psu_post_config_data
    init_ps [subst {$psu_post_config_data}]
}

proc psu_ps_pl_reset_config {} {
    variable psu_ps_pl_reset_config_data
    init_ps [subst {$psu_ps_pl_reset_config_data}]
}

proc psu_ps_pl_isolation_removal {} {
    variable psu_ps_pl_isolation_removal_data
    init_ps [subst {$psu_ps_pl_isolation_removal_data}]
}


proc mask_read { addr mask } {
    set curval "0x[string range [mrd -force $addr] end-8 end]"
    set maskedval [expr {$curval & $mask}]
    return $maskedval
}


proc mask_poll { addr mask } {
    set count 1
    set curval "0x[string range [mrd -force $addr] end-8 end]"
    set maskedval [expr {$curval & $mask}]
    while { $maskedval == 0 } {
        set curval "0x[string range [mrd -force $addr] end-8 end]"
        set maskedval [expr {$curval & $mask}]
        set count [ expr { $count + 1 } ]
        if { $count == 1000 } {
          puts "Timeout Reached. Mask poll failed at ADDRESS: $addr MASK: $mask"
          break
        }
    }
}

proc psu_mask_write { addr mask value } {
    set curval "0x[string range [mrd -force $addr] end-8 end]"
    set curval [expr {$curval & ~($mask)}]
    set maskedval [expr {$value & $mask}]
    set maskedval [expr {$curval | $maskedval}]
    mwr -force $addr $maskedval
}

proc serdes_fixcal_code {} {
	
	set MaskStatus 1
	array set match_pmos_code {}
	array set match_nmos_code {}
	array set match_ical_code {}
	array set match_rcal_code {}
	set p_code 0
	set n_code 0
	set i_code 0
	set r_code 0
	set repeat_count 0
	set L3_TM_CALIB_DIG20 0
    set L3_TM_CALIB_DIG19 0
    set L3_TM_CALIB_DIG18 0
    set L3_TM_CALIB_DIG16 0
    set L3_TM_CALIB_DIG15 0
    set L3_TM_CALIB_DIG14 0

  set rdata 0
  
  set rdata [mask_read 0XFD40289C 0xFFFFFFFF] 
  set rdata [expr $rdata & ~0x03 ]
  set rdata [expr $rdata | 0x1]  
  mask_write 0XFD40289C 0xFFFFFFFF $rdata
  #check supply good status before starting AFE sequencing
  set count 1
  while 1 {
    set rdata [mask_read 0xFD402B1C 0xFFFFFFFF]
    set count [ expr { $count + 1 } ]
    if { [expr $rdata & 0x0000000E] == 0x0000000E } {
      break;
    }
    if { $count == 1000 } {
      break;
    }
  }


	for {set i 0} {$i<23 } {incr i } {
	   set match_pmos_code($i) 0;
	   set match_nmos_code($i) 0;
	}
	
	for {set i 0}  {$i<7} {incr i} {
 	   set match_ical_code($i) 0;
	   set match_rcal_code($i) 0;
    }
	
	while 1 {
      #Clear ICM_CFG value
      mask_write 0xFD410010 0xFFFFFFFF 0x00000000
      mask_write 0xFD410014 0xFFFFFFFF 0x00000000

      #Set ICM_CFG value
      #This will trigger recalibration of all stages
      mask_write 0xFD410010 0xFFFFFFFF 0x00000001
      mask_write 0xFD410014 0xFFFFFFFF 0x00000000;

      #is calibration done? polling on L3_CALIB_DONE_STATUS
      mask_poll 0xFD40EF14  0x2;
      
	  #PMOS code	
      set p_code [mask_read 0xFD40EF18 0xFFFFFFFF]; 
	  #NMOS code
      set n_code [mask_read 0xFD40EF1C 0xFFFFFFFF]; 
      #ICAL code 
      set i_code [mask_read 0xFD40EF24 0xFFFFFFFF]; 
	  #RX code
      set r_code [mask_read 0xFD40EF28 0xFFFFFFFF]; 
      

      #xil_printf("#SERDES initialization VALUES NMOS = 0x%x, PMOS = 0x%x, ICAL = 0x%x, RCAL = 0x%x\n\r", p_code, n_code, i_code, r_code);
	  #PMOS code in acceptable range 	
      if {($p_code >= 0x26) && ($p_code <= 0x3C)} {
    	  set index [expr $p_code - 0x26]
		  set value $match_pmos_code($index) 
		  incr value
		  set match_pmos_code($index) $value;
      }
	  #NMOS code in acceptable range	
      if {($n_code >= 0x26) && ($n_code <= 0x3C)} {
        set index [expr $n_code - 0x26]
        set value $match_nmos_code($index)
        incr value    	
		set match_nmos_code($index) $value;
      }
      #PMOS code in acceptable range
      if {($i_code >= 0xC) && ($i_code <= 0x12)} {
      
    	set index [expr $i_code - 0xC]
        set value $match_ical_code($index)
        incr value    	
		set match_ical_code($index) $value;
		
      }
      #NMOS code in acceptable range
      if {($r_code >= 0x6) && ($r_code <= 0xC)} {
    	set index [expr $r_code - 0x6]
        set value $match_rcal_code($index)
        incr value    	
		set match_rcal_code($index) $value;
      }
	  
	  incr repeat_count 	
      if {$repeat_count > 10} {
	    break
	  }
   } 
	
	
   
   #find the valid code which resulted in maximum times in 10 iterations
   for {set i 0 } {$i < 23}  {incr i} {
   
	   if {$match_pmos_code($i) >= $match_pmos_code(0) } {
		   set match_pmos_code(0)  $match_pmos_code($i)
		   set p_code [expr 0x26 + $i]
	   }
	   if {$match_nmos_code($i)  >= $match_nmos_code(0)} {
	   
		   set match_nmos_code(0) $match_nmos_code($i)
		   set n_code [expr 0x26 + $i];
	   }
   }

   for {set $i 0} {$i<7} {incr i} {
	   if {$match_ical_code($i) >= $match_ical_code(0)} {
		   set match_ical_code(0) $match_ical_code($i)
		   set i_code [expr 0xC + $i]
	   }
	   if {$match_rcal_code($i) >= $match_rcal_code(0)} {
		   set match_rcal_code(0) $match_rcal_code($i)
		   set r_code [expr 0x6 + $i]
	   }
   }
   #xil_printf("#SERDES initialization PASSED NMOS = 0x%x, PMOS = 0x%x, ICAL = 0x%x, RCAL = 0x%x\n\r", p_code, n_code, i_code, r_code);
   #L3_TM_CALIB_DIG20[3] PSW MSB Override
   #L3_TM_CALIB_DIG20[2:0]	PSW Code [4:2]
   #read DIG20
   set L3_TM_CALIB_DIG20 [mask_read 0xFD40EC50  0xFFFFFFF0]; 
   set L3_TM_CALIB_DIG20 [expr $L3_TM_CALIB_DIG20 | 0x8 | (($p_code>>2)&0x7)]


   #L3_TM_CALIB_DIG19[7:6]	PSW Code [1:0]
   #L3_TM_CALIB_DIG19[5]	PSW Override
   #L3_TM_CALIB_DIG19[2]	NSW MSB Override
   #L3_TM_CALIB_DIG19[1:0]	NSW Code [4:3]
   #read DIG19
   set L3_TM_CALIB_DIG19  [mask_read 0xFD40EC4C 0xFFFFFF18]
   set L3_TM_CALIB_DIG19  [expr $L3_TM_CALIB_DIG19 | (($p_code&0x3)<<6) | 0x20 | 0x4 | (($n_code>>3)&0x3)]

   #L3_TM_CALIB_DIG18[7:5]	NSW Code [2:0]
   #L3_TM_CALIB_DIG18[4]	NSW Override
   #read DIG18
   set L3_TM_CALIB_DIG18  [mask_read 0xFD40EC48 0xFFFFFF0F] 
   set L3_TM_CALIB_DIG18  [expr $L3_TM_CALIB_DIG18 | (($n_code&0x7)<<5) | 0x10]


   #L3_TM_CALIB_DIG16[2:0]	RX Code [3:1]
   #read DIG16
   set L3_TM_CALIB_DIG16  [mask_read 0xFD40EC40 0xFFFFFFF8]  
   set L3_TM_CALIB_DIG16  [expr $L3_TM_CALIB_DIG16 | (($r_code>>1)&0x7)]

   #L3_TM_CALIB_DIG15[7]	RX Code [0]
   #L3_TM_CALIB_DIG15[6]	RX CODE Override
   #L3_TM_CALIB_DIG15[3]	ICAL MSB Override
   #L3_TM_CALIB_DIG15[2:0]	ICAL Code [3:1]
   #read DIG15
   set L3_TM_CALIB_DIG15 [mask_read 0xFD40EC3C 0xFFFFFF30]
   set L3_TM_CALIB_DIG15 [expr $L3_TM_CALIB_DIG15 | (($r_code&0x1)<<7) | 0x40 | 0x8 | (($i_code>>1)&0x7)]

   #L3_TM_CALIB_DIG14[7]	ICAL Code [0]
   #L3_TM_CALIB_DIG14[6]	ICAL Override
   #read DIG14
   set L3_TM_CALIB_DIG14 [mask_read 0xFD40EC38 0xFFFFFF3F]
   set L3_TM_CALIB_DIG14 [expr $L3_TM_CALIB_DIG14 | (($i_code&0x1)<<7) | 0x40]

   #Forces the calibration values
   mask_write 0xFD40EC50 0xFFFFFFFF $L3_TM_CALIB_DIG20
   mask_write 0xFD40EC4C 0xFFFFFFFF $L3_TM_CALIB_DIG19
   mask_write 0xFD40EC48 0xFFFFFFFF $L3_TM_CALIB_DIG18
   mask_write 0xFD40EC40 0xFFFFFFFF $L3_TM_CALIB_DIG16
   mask_write 0xFD40EC3C 0xFFFFFFFF $L3_TM_CALIB_DIG15
   mask_write 0xFD40EC38 0xFFFFFFFF $L3_TM_CALIB_DIG14 


   return $MaskStatus;
 }
proc serdes_enb_coarse_saturation {} { 
   #/* 
   # * Enable PLL Coarse Code saturation Logic
   # */
   mask_write 0xFD402094 0xFFFFFFFF 0x00000010 
   mask_write 0xFD406094 0xFFFFFFFF 0x00000010 
   mask_write 0xFD40A094 0xFFFFFFFF 0x00000010 
   mask_write 0xFD40E094 0xFFFFFFFF 0x00000010

}

proc init_serdes {} {
  serdes_fixcal_code
  serdes_enb_coarse_saturation

}

proc poll { addr mask data} {
    set curval "0x[string range [mrd -force $addr] end-8 end]"
    set maskedval [expr {$curval & $mask}]
    set count 1
    while { $maskedval != $data } {
        set curval "0x[string range [mrd -force $addr] end-8 end]"
        set maskedval [expr {$curval & $mask}]
        set count [ expr { $count + 1 } ]
        if { $count == 100000000 } {
          puts "Timeout Reached. Mask poll failed at ADDRESS: $addr MASK: $mask"
          break
        }
    }
}

proc init_peripheral {} {
#SMMU_REG Interrrupt Enable: Followig register need to be written all the time to properly catch SMMU messages.
   mask_write 0xFD5F0018 0x8000001F 0x8000001F 
}
proc psu_init_xppu_aper_ram {} {

}


proc psu_lpd_protection {} {
}

proc psu_ddr_protection {} {
    set saved_mode [configparams force-mem-accesses]                  
    configparams force-mem-accesses 1 
    
    variable psu_ddr_xmpu0_data
    variable psu_ddr_xmpu1_data
    variable psu_ddr_xmpu2_data
    variable psu_ddr_xmpu3_data
    variable psu_ddr_xmpu4_data
    variable psu_ddr_xmpu5_data
    init_ps [subst {$psu_ddr_xmpu0_data  $psu_ddr_xmpu1_data  $psu_ddr_xmpu2_data  $psu_ddr_xmpu3_data  $psu_ddr_xmpu4_data  $psu_ddr_xmpu5_data}]
    
	configparams force-mem-accesses $saved_mode                                       
}

proc psu_ocm_protection {} {
    set saved_mode [configparams force-mem-accesses]                  
    configparams force-mem-accesses 1 
    
    variable psu_ocm_xmpu_data
    init_ps [subst {$psu_ocm_xmpu_data }]
    
	configparams force-mem-accesses $saved_mode                                       
}

proc psu_fpd_protection {} {
    set saved_mode [configparams force-mem-accesses]                  
    configparams force-mem-accesses 1 
    
	variable psu_fpd_xmpu_data
    init_ps [subst {$psu_fpd_xmpu_data }]
    
	configparams force-mem-accesses $saved_mode                                       
}

proc psu_protection_lock {} {
    set saved_mode [configparams force-mem-accesses]                  
    configparams force-mem-accesses 1 
    
	variable psu_protection_lock_data
    init_ps [subst {$psu_protection_lock_data }]
    
	configparams force-mem-accesses $saved_mode                                       
}

proc psu_protection {} {
  variable psu_apply_master_tz
   init_ps [subst {$psu_apply_master_tz }]
   psu_ddr_protection
   psu_ocm_protection
   psu_fpd_protection
   psu_lpd_protection
}

set psu_ddr_init_data  { }

proc psu_ddr_phybringup_data {} { }
